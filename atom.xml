<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>崎岖的路,走出自己的脚步</title>
  <subtitle>崎岖的路,走出自己的脚步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dingran.tk/"/>
  <updated>2017-07-05T07:28:27.000Z</updated>
  <id>http://dingran.tk/</id>
  
  <author>
    <name>D.R</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>防刷限制ip设计</title>
    <link href="http://dingran.tk/2017/07/05/%E9%98%B2%E5%88%B7%E9%99%90%E5%88%B6ip%E8%AE%BE%E8%AE%A1/"/>
    <id>http://dingran.tk/2017/07/05/防刷限制ip设计/</id>
    <published>2017-07-05T07:24:02.000Z</published>
    <updated>2017-07-05T07:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，发现DTC的余位查询接口在每天的12~13点左右，流量飙升3倍左右，然后又回落，如果经过系统关键字查询发现查询是来自APP端的访问，那么这就有可能是我们的接口被人家给刷了，作为底层系统，我需要保证接口的高效性，如果接口被人刷了就会导致真正需要接口数据的准确性。</p>
<p>由于是底层系统，所以我没有办法获得客户端的ip，于是先让PHP把客户端ip透传过来，我对ip的查询速度进行限制。网上这种限制的资料太多了，等我设计好了再补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间，发现DTC的余位查询接口在每天的12~13点左右，流量飙升3倍左右，然后又回落，如果经过系统关键字查询发现查询是来自APP端的访问，那么这就有可能是我们的接口被人家给刷了，作为底层系统，我需要保证接口的高效性，如果接口被人刷了就会导致真正需要接口数据的准确性。
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下配置squid+账号密码认证+高匿</title>
    <link href="http://dingran.tk/2017/06/30/Linux%E4%B8%8B%E9%85%8D%E7%BD%AEsquid-%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81-%E9%AB%98%E5%8C%BF/"/>
    <id>http://dingran.tk/2017/06/30/Linux下配置squid-账号密码认证-高匿/</id>
    <published>2017-06-30T06:22:56.000Z</published>
    <updated>2017-06-30T06:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="squid-搭建过程"><a href="#squid-搭建过程" class="headerlink" title="squid 搭建过程"></a>squid 搭建过程</h1><p>由于我们之前使用的阿里云的代理ip配置的代理服务器，由于领导要我们使用亚马逊云配置代理服务器，所以交给我任务去配置代理服务器，还得兼容以前的形式，也就说账号+密码的形式登录代理，访问网站。</p>
<p>我觉得很简单，网上有很多配置的信息，结果搜下来有很多都是大家相互复制的垃圾文章，要不就是虎头蛇尾，要不就是没头没尾，弄得我脑袋都大了，经过昨天晚上的资料筛选，今天我开启了AWS的配置，创建了个实例就不说了直接跳入配置过程：</p>
<h2 id="首先先判断是否安装squid："><a href="#首先先判断是否安装squid：" class="headerlink" title="首先先判断是否安装squid："></a>首先先判断是否安装squid：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -q squid</div></pre></td></tr></table></figure>
<h2 id="如果安装了不行就卸载了吧"><a href="#如果安装了不行就卸载了吧" class="headerlink" title="如果安装了不行就卸载了吧"></a>如果安装了不行就卸载了吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">rpm -e squid</div></pre></td></tr></table></figure>
<h2 id="再进行下载squid"><a href="#再进行下载squid" class="headerlink" title="再进行下载squid"></a>再进行下载squid</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">yum install squid</div></pre></td></tr></table></figure>
<h2 id="下载httpd-为后面进行认证做准备"><a href="#下载httpd-为后面进行认证做准备" class="headerlink" title="下载httpd 为后面进行认证做准备"></a>下载httpd 为后面进行认证做准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install httpd</div></pre></td></tr></table></figure>
<h2 id="下载好了后，配置-etc-squid-squid-conf-这个比较重要"><a href="#下载好了后，配置-etc-squid-squid-conf-这个比较重要" class="headerlink" title="下载好了后，配置/etc/squid/squid.conf 这个比较重要"></a>下载好了后，配置/etc/squid/squid.conf 这个比较重要</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#</div><div class="line"># INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS</div><div class="line"># =======================</div><div class="line"></div><div class="line"># 禁止缓存任何内容，纯代理</div><div class="line">cache deny all</div><div class="line"></div><div class="line"># 禁用access_log</div><div class="line">access_log none</div><div class="line"></div><div class="line"># 禁用cache_store log</div><div class="line">cache_store_log none</div><div class="line"></div><div class="line"># 禁用cache log</div><div class="line">cache_log /dev/null </div><div class="line"></div><div class="line"># 使用basic_nsca_auth认证</div><div class="line">auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd</div><div class="line">auth_param basic children 5</div><div class="line">auth_param basic credentialsttl 2 hours</div><div class="line">auth_param basic realm Do you have rights to access?</div><div class="line">auth_param basic casesensitive off</div><div class="line">acl ncsa_users proxy_auth REQUIRED</div><div class="line">http_access allow localnet</div><div class="line">http_access allow localhost</div><div class="line">http_access allow ncsa_users</div><div class="line">http_port 8888</div><div class="line"></div><div class="line">#以上配置部分要在http_access deny all语句之前。</div><div class="line"></div><div class="line"># 这部分可以放在配置文件末尾，避免被网站检测到你在使用proxy</div><div class="line"># =======================</div><div class="line">via off</div><div class="line">forwarded_for off</div><div class="line">request_header_access Allow allow all </div><div class="line">request_header_access Authorization allow all </div><div class="line">request_header_access WWW-Authenticate allow all </div><div class="line">request_header_access Proxy-Authorization allow all </div><div class="line">request_header_access Proxy-Authenticate allow all </div><div class="line">request_header_access Cache-Control allow all </div><div class="line">request_header_access Content-Encoding allow all </div><div class="line">request_header_access Content-Length allow all </div><div class="line">request_header_access Content-Type allow all </div><div class="line">request_header_access Date allow all </div><div class="line">request_header_access Expires allow all </div><div class="line">request_header_access Host allow all </div><div class="line">request_header_access If-Modified-Since allow all </div><div class="line">request_header_access Last-Modified allow all </div><div class="line">request_header_access Location allow all </div><div class="line">request_header_access Pragma allow all </div><div class="line">request_header_access Accept allow all </div><div class="line">request_header_access Accept-Charset allow all </div><div class="line">request_header_access Accept-Encoding allow all </div><div class="line">request_header_access Accept-Language allow all </div><div class="line">request_header_access Content-Language allow all </div><div class="line">request_header_access Mime-Version allow all </div><div class="line">request_header_access Retry-After allow all </div><div class="line">request_header_access Title allow all </div><div class="line">request_header_access Connection allow all </div><div class="line">request_header_access Proxy-Connection allow all </div><div class="line">request_header_access User-Agent allow all </div><div class="line">request_header_access Cookie allow all </div><div class="line">request_header_access All deny all</div><div class="line"># =======================</div></pre></td></tr></table></figure>
<p>squid.conf配置里面还有很多其他的配置，网上有很多详细的配置说明，这里不多介绍。在squid.conf开头我配置auth进行账号密码认证后才能访问。</p>
<h2 id="账号密码配置过程"><a href="#账号密码配置过程" class="headerlink" title="账号密码配置过程"></a>账号密码配置过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">htpasswd -c /etc/squid/passwd gavin</div><div class="line">#这里会让你设置密码</div><div class="line">##在确认一下密码</div><div class="line">###设置完成</div></pre></td></tr></table></figure>
<h2 id="校验配置文件配置"><a href="#校验配置文件配置" class="headerlink" title="校验配置文件配置"></a>校验配置文件配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">squid -z</div><div class="line">#如果squid 没有配置环境变量，到/usr/sbin下面执行squid</div></pre></td></tr></table></figure>
<p>执行完后会有一些信息，如果配置文件信息错误会有相关提示，更改就好</p>
<h2 id="最后启动squid"><a href="#最后启动squid" class="headerlink" title="最后启动squid"></a>最后启动squid</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">squid start</div></pre></td></tr></table></figure>
<h2 id="查看端口状况"><a href="#查看端口状况" class="headerlink" title="查看端口状况"></a>查看端口状况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">netstat -anp|grep 8888</div></pre></td></tr></table></figure>
<p>最后退出云服务器，在本地浏览器配置代理使用服务器公网ip+端口号，打开百度后会有显示让你输入账号密码就成功了，输入账号密码就可以登录浏览网页了</p>
<p>完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;squid-搭建过程&quot;&gt;&lt;a href=&quot;#squid-搭建过程&quot; class=&quot;headerlink&quot; title=&quot;squid 搭建过程&quot;&gt;&lt;/a&gt;squid 搭建过程&lt;/h1&gt;&lt;p&gt;由于我们之前使用的阿里云的代理ip配置的代理服务器，由于领导要我们使用亚马逊
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>免费代理集成dtc使用明细</title>
    <link href="http://dingran.tk/2017/06/28/%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E9%9B%86%E6%88%90dtc%E4%BD%BF%E7%94%A8%E6%98%8E%E7%BB%86/"/>
    <id>http://dingran.tk/2017/06/28/免费代理集成dtc使用明细/</id>
    <published>2017-06-28T03:14:06.000Z</published>
    <updated>2017-06-28T10:10:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>经历种种问题，终于将免费代理ip集成到DTC系统当中，之前由于各种问题，被我暂停，6.26号上线后，正式被我打开，打开后，在6.27号跑了一天后，我可以统计代理ip和免费代理ip的使用信息，其中代理ip使用了近150W次，而成功爬取数据成功的只有一半，再看免费代理ip，代替花钱买的代理ip抓取数据并且成功的数量在130w左右，说明了什么？免费代理ip几乎帮助dtc系统顶了将近一半的查询12306的数据。</p>
<p>免费代理ip质量参差不齐，所以用它们去抓取价格、抓取经停站简直是绝配了，这两天我将代理ip和免费代理ip的使用明细全部统计出来，余位接口、抢票接口、价格接口、经停站接口等使用了多少，失败了多少，各个角度去统计ip使用率，为后面更好统计我们使用代理ip的数量提供了更好的数据支持（可恶的黄甲天天催）。</p>
<p>这是上线第一天的数据量，但是从我今天的统计来看，免费代理ip的有效率占ip使用总数比例几乎是1：1的，有所增加，这也是情理之中的，因为随着时间的增长，花钱买的代理ip的有效率肯定会下降的，但是免费代理ip就会有新鲜的ip加进来，维持高效爬取数据，所以最终我初步断定免费代理ip能够贡献的爬取树量占花钱买的代理ip的贡献量50%左右,这是一个挺不错的数字,但是今天我却发现免费代理ip使用数量和我们线上买的代理ip使用的总数量一致，但是但是但是说三遍，线上有47%的失败率。什么意思?就是说免费代理ip的贡献率是我们花钱买到的代理ip的三倍左右，如果我们之前使用1000个代理ip现在我们就可以少买666个代理ip，一个代理ip80块，就是5w+，也就说至少可以节省一半的ip的预算。</p>
<p>这个小爬虫是我自己的想法，当初不被任何人看好，现在却带来了巨大的红利，我会继续再接再厉，提高抓取爬虫的有效率，继续做点有意义的事情出来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历种种问题，终于将免费代理ip集成到DTC系统当中，之前由于各种问题，被我暂停，6.26号上线后，正式被我打开，打开后，在6.27号跑了一天后，我可以统计代理ip和免费代理ip的使用信息，其中代理ip使用了近150W次，而成功爬取数据成功的只有一半，再看免费代理ip，代替
    
    </summary>
    
      <category term="日记月累" scheme="http://dingran.tk/categories/%E6%97%A5%E8%AE%B0%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>集成爬虫到DTC系统以及相关问题总结</title>
    <link href="http://dingran.tk/2017/06/23/%E9%9B%86%E6%88%90%E7%88%AC%E8%99%AB%E5%88%B0DTC%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/06/23/集成爬虫到DTC系统以及相关问题总结/</id>
    <published>2017-06-23T07:16:58.000Z</published>
    <updated>2017-06-23T07:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>6.21号，我把带有爬取免费代理ip的爬虫放到线上，结果部署完成后发现redis不停的报一个错–unexpected stream。上网搜了一下，大概都是缓存空间不够或者多个线程一起调用的问题，但是我觉得用起来根不是这些问题。在测试环境都没有发现这种问题。后来请教运维相关人员瞬间我知道自己出现的问题在哪了。</p>
<p>在代码里面，我使用brpop命令来进行监听某个redis队列是否有数据，类似java的blockingqueue，我之前满心欢喜，这个功能真的好用，但是到了线上就完犊子了，原因是我们线上的redis使用的twemproxy这个twitter的redis代理来进行redis的管理。这个twemproxy可以自动剔除坏掉的节点，比较好用，但是它也有它的缺点就是它不支持一些redis的命令，brpop是其中一个，还有订阅发布等都不支持。有点沮丧，没办法，只能自己去实现这功能了。</p>
<p>昨天6.22号又紧急上线了，我是搭车上线主要是修复一些小问题，顺便把redis这个brpop这个修改了。然后再次发布，到线上后一切正常，然后到了今天早上，我来的时候突然发现dtc系统不提供服务了，经过visualvm链接线上的jvm查看，看见线程活跃说已经达到2800+了，我知道是自己在代码里面创建了一个线程池频繁销毁启动造成的，还好自己做了开关，我将开关关闭，将每台服务器都启动了一遍，多有实例都可以提供服务，没有问题。再看代码再将销毁线程池的地方再次修改，等待下次上线日。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6.21号，我把带有爬取免费代理ip的爬虫放到线上，结果部署完成后发现redis不停的报一个错–unexpected stream。上网搜了一下，大概都是缓存空间不够或者多个线程一起调用的问题，但是我觉得用起来根不是这些问题。在测试环境都没有发现这种问题。后来请教运维相关人
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>DTC集成智能小爬虫抓取免费ip</title>
    <link href="http://dingran.tk/2017/06/18/DTC%E9%9B%86%E6%88%90%E6%99%BA%E8%83%BD%E5%B0%8F%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%85%8D%E8%B4%B9ip/"/>
    <id>http://dingran.tk/2017/06/18/DTC集成智能小爬虫抓取免费ip/</id>
    <published>2017-06-17T16:40:05.000Z</published>
    <updated>2017-06-17T17:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>6.18，年中了，自己马上就要在途牛干了将近1年了，回头望来感慨万千。哎，华奥司机是不是走的有点早啊，再呆上3个月，可能比你之前呆的那一年经历的坑还多呢。</p>
<p>已经是深夜，今天还是父亲节，今天早上起来得给父亲打个电话，谁让我是个大孝子呢，哎没办法。没事写写博客回忆今天做的事情也是蛮快乐的事情呀。</p>
<p>这两天是京东618的日子，每个组都需要有个人值班，虽说我不是这个值班的人，但是我还是本着“工（赚）作（加）至（班）上（费）”的原则还是不请自来了，既然来了也要必须做点事情呀，谁让我的价值观这么高呢。扯远了开始正题：</p>
<p>我先在自己的机器上搭建了一个小java工程，这个工程主要是用来爬取网上的免费代理ip，这一段时间以来12306几乎把我们所有的代理ip全部封掉了，即使买一些新的上去，最多几分钟就挂了，所以我需要一些炮灰来帮我刷新一些数据。由于代理ip不够用了，幸亏之前上了APP反刷（不是火车票列表反刷），之前不看好的功能现在居然成了主力，如果这个功能不上的话，也许数据中心真就直接倒闭了。但是由于查询量太大，app反刷也有些扛不住了，不得已走缓存了，所以数据准确性还真的有待提升。但是这只是个临时的策略，代理ip还是必须得上，否则数据的准确度绝对达不到的。</p>
<p>我把代理的逻辑仔细排查了一下（都看了860遍了，谁写破B玩应），发现了代理ip耗时最多的地方就是价格抓取和经停站的抓取，一次简单的查询，到了后面异步抓取了N多数据，所以代理ip消耗很大，所以有了我之前写的小智能爬虫。</p>
<p>这个爬虫很简单，就是不停的分析页面，抓取有效的信息，不能抓取的过快，否则也有会被封的危险。我在本机上跑的时候很短时间轻松抓取3~5w的代理ip，量很大，但是都需要check，check是最费时的，这么多抓来的ip靠线程池check真是太慢了，我在本机上起了2000+线程直接报错不能在创建线程了，虽然check的慢，但是还是有很多可以用的，中午有一阵居然可以获取2000+的有效代理ip，平时的话也就500左右。</p>
<p>我当初想在本地跑程序，将check后的代理ip放给线上，后来发现本地check太慢，而且不够灵活，我需要随时能够抓取发往线上，线上消耗这个代理ip的速度太惊人了，几乎放上去瞬间就被用光了，所以我还是决定将这个spider集成到dtg里面，作为一个独立的模块，添加定时任务，跑的时候，将没有check的ip用redis队列push进去，由于线上有很多实例，所以我在每个实例上进行监听这个队列，有数据在pop出来，pop500到本地，然后不够500在pop，本地就check数据，这样通过集群的话，check代理ip效率会更高，否则抓取的这么多的代理ip check不完就浪费了。check的时候用线程池，这个都会想到，但是check这个代理ip可能会花费很长时间，什么意思呢？就是线程池会满，如果到了下次触发抓取的时候，继续check这么下去，线程池不崩溃才怪呢。所以我尝试了好多方法，终于找到了一种每次触发都重新创建线程池，之前没处理的线程池直接shutdown掉，给后来的让位置，加上使用单例模式跑起来几乎没有什么问题。我在本地测试，启动在190个线程左右，开始check的时候线程飙到400左右，shutdown后落回200左右，然后定时再触发，再次回到400，这样往复，没错虽然可能会消耗很多资源，但是总起评价来还是值得的。</p>
<p>今天算是把代理集成起来，争取下周上线，后面再把统计抓取免费代理ip数量，check后的数量，真正使用的数量每隔半个小时统计出来，发到我的邮箱。这样可以给黄甲看看当初他看不起的免费代理ip到底支起了多大的天空。</p>
<p>困了，不早了，就到这里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6.18，年中了，自己马上就要在途牛干了将近1年了，回头望来感慨万千。哎，华奥司机是不是走的有点早啊，再呆上3个月，可能比你之前呆的那一年经历的坑还多呢。&lt;/p&gt;
&lt;p&gt;已经是深夜，今天还是父亲节，今天早上起来得给父亲打个电话，谁让我是个大孝子呢，哎没办法。没事写写博客回忆
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>12306app抓包</title>
    <link href="http://dingran.tk/2017/06/11/12306app%E6%8A%93%E5%8C%85/"/>
    <id>http://dingran.tk/2017/06/11/12306app抓包/</id>
    <published>2017-06-11T05:24:33.000Z</published>
    <updated>2017-06-11T05:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直有个想法就是想抓取app上面的访问方式，昨天在网上搜索后发现app可以通过fiddler来抓包，可惜的是fiddler在mac上面不是很友好，今天来到公司，用自己的工作电脑搭建了一个fiddler，网上教程一大把，随便找了一个，按照教程配置好后，将自己的手机连上局域网，打开手机app 就可以抓包了，很简单。</p>
<p>我主要是抓取12306app的余位查询，经过抓包后，我发现参数基本没有什么变化，但是多了几个，比如checkcode等，返回的信息是加密后的乱码，我的心这个凉呀，没办法了，因为我解密不了，还是要请教其他人了，看看能否解密。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直有个想法就是想抓取app上面的访问方式，昨天在网上搜索后发现app可以通过fiddler来抓包，可惜的是fiddler在mac上面不是很友好，今天来到公司，用自己的工作电脑搭建了一个fiddler，网上教程一大把，随便找了一个，按照教程配置好后，将自己的手机连上局域网，
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>Rx_java</title>
    <link href="http://dingran.tk/2017/06/03/Rx-java/"/>
    <id>http://dingran.tk/2017/06/03/Rx-java/</id>
    <published>2017-06-03T02:29:22.000Z</published>
    <updated>2017-06-03T08:05:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rxJava是什么"><a href="#rxJava是什么" class="headerlink" title="rxJava是什么"></a>rxJava是什么</h1><blockquote>
<p>a library for composing asynchronous and event-based programs using observable sequences for the Java VM</p>
</blockquote>
<p>一个对于构成使用的Java虚拟机观察序列异步和基于事件的程序库</p>
<p>github：<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">https://github.com/ReactiveX/RxJava</a></p>
<p>详细信息可以参考：</p>
<p><a href="http://www.oschina.net/p/rxjava" target="_blank" rel="external">http://www.oschina.net/p/rxjava</a></p>
<p><a href="http://www.jianshu.com/p/845549ac4623" target="_blank" rel="external">http://www.jianshu.com/p/845549ac4623</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;rxJava是什么&quot;&gt;&lt;a href=&quot;#rxJava是什么&quot; class=&quot;headerlink&quot; title=&quot;rxJava是什么&quot;&gt;&lt;/a&gt;rxJava是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;a library for composing async
    
    </summary>
    
      <category term="java" scheme="http://dingran.tk/categories/java/"/>
    
    
      <category term="java" scheme="http://dingran.tk/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>APP反刷余位信息上线</title>
    <link href="http://dingran.tk/2017/06/02/APP%E5%8F%8D%E5%88%B7%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%BD%99%E4%BD%8D%E4%BF%A1%E6%81%AF%E4%B8%8A%E7%BA%BF/"/>
    <id>http://dingran.tk/2017/06/02/APP反刷火车票余位信息上线/</id>
    <published>2017-06-02T07:33:58.000Z</published>
    <updated>2017-06-02T08:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>说起app反刷的功能，在火车票数据中心有两个：</p>
<p>第一个是在查询的火车票列表的时候进行反刷12306的余位信息给我们，由于我们的代理ip是有限的，不是每个请求都能分配到代理ip，故而这种情况再返回缓存的时候如果缓存过期就让app去12306获取余位信息，将最新余位信息刷给我们，我们组装信息再返回给前端。最终效果不是很好，会出现卡顿的效果暂时关闭状态。</p>
<p>还有一个app反刷，也是用来处理余位更新的。也是为了节省代理ip，原理就是在手机端开启个线程，每隔一段时间去数据中心访问是否有数据需要抓取。而数据中心这边在代理ip不足的情况下，便需要将抓取的url放进队列里面，手机端的请求每次都从队列里面取数据，这样如果手机端取到数据就直接去访问12306，然后再将获取的结果发送给数据中心，整个流程下来需要在5秒以内完成。</p>
<p>整个反刷功能已经开发好一段时间了，由于现在请求量也不是很大，所以这个功能一直没有开启。最近6.1号开始卖学生票了，由于成人票和学生票是两个接口，代理ip在抓取学生票的时候出现大量被封的现象，被封率达到99%；由于成人票和学生票的代理ip使用逻辑是一套的，这样不仅影响学生票售卖，还影响成人票的售卖。由于学生票接口开始被封，最近又开始卖学生票，没办法只能先将学生票的接口走成人票接口。</p>
<p>走成人票接口只是权宜之计，首先我想先买一批代理ip，从中测试学生票接口能够用的拿出来，其他的给成人票使用，但是询问后得知代理不能够先测试使用，如果买了50个代理ip能够使用的只有40个话，那就亏大了。我爬取ip的小爬虫也写好了但是抓取了3W+的ip能够使用的也就400~500个，关键是不够稳定，放到测试环境还是可以的，放到线上根本不行，于是我想起了app反刷。</p>
<p>稍微修改一下代码，将学生票全部切到app反刷，上线后，我测试了一下，效果不是很好，经常出现查询为空的现象而且再次加载还是为空。经过排查，是我在放入队列的时候做了限制，一个站战对团期只能放入一次，是我想的太多了，因为不是每个放入的数据都能返回来的，去掉这个限制，再次在sit环境测试，效果还不是很好，和前端一起排查，经过推敲分析，发现放入队列的数据，前端查询12306的时候也会出现返回为空的现象。后来前端提醒我可以多放入队列两次，我瞬间豁然开朗，怎么没想到呢？因为线上不是每个人的手机都网速畅通的，有可能像花生地铁这种比较low的，我多放入两次就可以有几率被网速相对好一点的取走，快速返回结果，就会更快返回火车票列表数据。</p>
<p>再次修改代码，将放入队列次数配置在diamond，先配置3次，重新打包。在前端和测试的共同验证下，放进3个，取走3个，查询成功的只有1一个返回，我这边的列表也显示正常，这就看出来不是每次请求都成功，失败率还是挺高的。今天有紧急上线，于是我搭上这趟快车，将代码上线。上线完成后我将配置改为4次，加大查询效率。在app端查询学生票，显示效果还不错，也会出现查询不出来的情况，但是再刷一次就出来了，还可以接受。</p>
<p>app反刷这个功能能够实现，前提是必须有大量的请求才能实现，我监控了一段时间发现这段时间请求量大平稳可以使用，也可算是个小小的里程碑。学生票使用这个功能算是告一段落，后面还要接入成人票。</p>
<p>回头再看这个学生票的解决，内心坎坷呀，由于产品催的紧还和产品小吵了一下，说到底还是自己太浮躁，脾气咋这么大腻？也是自己要好好反思的地方。还好产品心胸开阔，不和我见识，还请我喝奶茶（应该是我请人家啦），实在让我无地自容。这次也算是给自己积累了一些经验，能够在后面乃至将来的工作中应对各种问题更加自如。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起app反刷的功能，在火车票数据中心有两个：&lt;/p&gt;
&lt;p&gt;第一个是在查询的火车票列表的时候进行反刷12306的余位信息给我们，由于我们的代理ip是有限的，不是每个请求都能分配到代理ip，故而这种情况再返回缓存的时候如果缓存过期就让app去12306获取余位信息，将最新余
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>工作总结</title>
    <link href="http://dingran.tk/2017/05/24/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/05/24/工作总结/</id>
    <published>2017-05-24T03:27:30.000Z</published>
    <updated>2017-05-24T04:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>从过年到现在过去了三个月，这段时间可能是我入职途牛以来干的事情最有成果，也是自己最有收获的几个月。这几月熟悉的老司机一个一个离开，自己的身上的单子也越来越重，12306也不省心，三天两头的变动接口，最近还更换了接口的返回数据结构。</p>
<p>这段时间里面，主要是负责数据中心的DTC系统的改造，原来负责的牛抢票业务跟着迭代走就可以了，抢票也几乎没什么需求，但是dtc的问题太多了，急需整改，经过了三个月的整改，主要以下的成果：</p>
<ul>
<li><p>DTC的接口响应时间由原来的3秒左右提高到1.5秒以内，大部分车辆几百毫秒，向上海到南京有260+的车辆，响应时间也在1秒左右。</p>
</li>
<li><p>DTC价格问题抓取不准确，经过整改，价格每天抓取一次，价格带有新鲜度，超过新鲜度会再次出发抓取，每天的价格必须要有。</p>
</li>
<li><p>缓存插入失败问题，这个是我意外查到的每天大概有上千次插入缓存失败，经过排查是获取不到连接池，并且jar包太古老。升级完jar包后，适量增大redis连接池，现在已经没有插入缓存失败的问题。</p>
</li>
<li><p>JVM堆区不正常的偏大GC频繁。我经常用jvisualvm监控线上jvm情况，发现jvm堆有点大，快要溢出了，打了dump后，用eclipse的分析工具发现，在某个代码里面有个全局queue，不断往里面放数据，消费者却很慢，造成数据成倍增加。改造完成后，queue里面的数据几乎很快被消费掉，再次监控jvm堆得数据也恢复了正常水平。</p>
</li>
<li><p>DTC增加抢票专用接口 其实这个接口就是只查询余位信息，不查价格的接口。余位监控只关注是否有余位。这样可以节省很多代理ip的消耗问题。这个接口并发量比较大，一天的查询量平时大概几百万，春运期间大概有上千万的查询量。</p>
</li>
<li><p>线程池的使用问题。平时对配置线程池的参数没有什么概念，但是现在发现配置线程池参数很重要。经过合理配置，系统的线程由原来启动1000+降到现在500左右，没有出现问题。</p>
</li>
</ul>
<p>这段时间有的时候很是折磨，但是看到现在系统平稳运行，心理还是十分高兴地。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从过年到现在过去了三个月，这段时间可能是我入职途牛以来干的事情最有成果，也是自己最有收获的几个月。这几月熟悉的老司机一个一个离开，自己的身上的单子也越来越重，12306也不省心，三天两头的变动接口，最近还更换了接口的返回数据结构。&lt;/p&gt;
&lt;p&gt;这段时间里面，主要是负责数据
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>搭建代理ip仓库想法</title>
    <link href="http://dingran.tk/2017/05/20/%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86ip%E4%BB%93%E5%BA%93%E6%83%B3%E6%B3%95/"/>
    <id>http://dingran.tk/2017/05/20/搭建代理ip仓库想法/</id>
    <published>2017-05-20T02:42:01.000Z</published>
    <updated>2017-05-20T03:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.20号周六，今天来到公司来加班，公司的环境比较好，既可以学习，又可以做剩下的工作，还可以拿加班费^_^</p>
<p>刚才打了那么多字，可恶的ultraEdit退出了，还没保存！！</p>
<p>途牛火车票的盈利点很简单，至少我是这么认为的，就是在乘客购买火车票的时候能够购买保险，但是总起计算下来客户购买保险所占的比例还是不高的。但是火车票部门每个月的花费还是多的，这里面有一项就是代理ip的费用。</p>
<p>由于12306会不定时对过于频繁访问的用户进行限制，但是超过一定的限制，这种访问的限制有可能是长期的，所以我们在抓取12306信息的时候都会使用代理ip，模拟多客户端多用户访问12306，让12306不能够轻易的屏蔽我们，我们这边控制好代理ip的使用频率，平时应该没有什么问题，但是常在河边走，哪能不湿鞋，碰到流量大的时候，也会有几个代理ip被屏蔽的现象。</p>
<p>代理ip的费用还是蛮贵的，有阿里云、京东等供应商，价格也都在几十块一个月不等。途牛火车票在平时购买车票不多的情况下，也需要几百个代理ip，遇到春运的时候购买上千个也不在话下。所以代理ip的费用占途牛火车票每个月的预算的大部分了。如果代理ip十分好用也就不说了，但是不是每个代理ip都是十分高效抓取数据，这让我十分头疼，比如昨天的学生票接口使用代理ip就死活访问不了，几乎全军覆没，而成人票接口就没有问题。可能说和代理ip没有关系，但是在本地就是可以的，或者我换用其他新鲜的代理ip就是可以的。</p>
<p>由于以上的原因，我萌生了一个想法，搭建代理ip的仓库。网上有很多的免费的代理ip，没错有很多代理ip是不能用的，但是数量多呀，有一万个，1%能用也是不错的，我准备分为两步走：</p>
<p>第一步：先固定抓取一部分页面，获取代理ip，先测试成功率能够有多少</p>
<p>第二步：直接使用搜索引擎（百度和谷歌）然后利用搜索引擎返回的url再次进行爬取，获取页面里面的代理ip，说到底就是做个智能爬虫，能够解析页面抓取ip</p>
<p>美好的想法肯定有对应的目标：</p>
<ul>
<li><p>满足自己数据中心抓取12306代理ip的使用</p>
</li>
<li><p>满足自己后，就可以给公司其他使用代理ip部门提供代理ip，比如机票等</p>
</li>
<li><p>公司满足后，就可以向外出售动态代理ip（太长远了）</p>
</li>
</ul>
<p>想法是付诸于实现的基石，我很高兴自己有这种想法，而不是浑浑噩噩的做着开发，因为我不是一个满足现状的人，我渴望有fresh的idea来充实自己，让自己的脑细胞尽量更多使用起来，而不是在那等死，即使那会让我很困。（学习新知识会让人疲倦厌恶摒弃）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.20号周六，今天来到公司来加班，公司的环境比较好，既可以学习，又可以做剩下的工作，还可以拿加班费^_^&lt;/p&gt;
&lt;p&gt;刚才打了那么多字，可恶的ultraEdit退出了，还没保存！！&lt;/p&gt;
&lt;p&gt;途牛火车票的盈利点很简单，至少我是这么认为的，就是在乘客购买火车票的时候能
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>抢票接口并发问题记录二</title>
    <link href="http://dingran.tk/2017/05/18/%E6%8A%A2%E7%A5%A8%E6%8E%A5%E5%8F%A3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%BA%8C/"/>
    <id>http://dingran.tk/2017/05/18/抢票接口并发问题记录二/</id>
    <published>2017-05-18T06:55:43.000Z</published>
    <updated>2017-05-18T07:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.17号早上大概10点，尝试调用抢票的接口，已经直接返回false，无法查询准确的数据，今天把昨天的日志拽下来（昨天的日志会自动copy到一个ftp目录下面），使用linux命令解压日志文件，我预估计可能是线程池满了，直接溢出了，但是正常情况下，应该不会出现这种问题，况且我使用2个线程池，在切换线程池的时候，我还打印了一部分日志—打印线程池的一些参数.经过排查日志，发现在早上6点的时候，第一个线程池已经满了，所有的请求已经递交到第二个线程池了，到了9点左右，第二个线程池也满了，所有后续的请求就直接放不进线程池，就直接丢弃报异常。下面try catch捕捉异常直接反馈前端查询失败。</p>
<p>解决办法：刚开始打算是准备给线程配置超时时间，如果线程超过了配置时间就强制停掉，但是后来想线程不是想停就停的，也就说线程启动了不是很听话的。又想增大线程池，但是上网看到一句话，让我豁然开朗，“没有找到线程阻塞的原因，就是放再大的线程池，线程池迟早会满”，就是时间的问题。看来还是自己的代码写的有问题。不找到根本问题，接口无法在高并发下提供服务。</p>
<p>但是回头来想，所有相关接口的地方，我都已经做好控制了，不会出现线程阻塞的情况呀，一行一行看代码，结合日志我终于发现了一个异常点：由于代理ip的问题，可能会出现connect refuse的情况，在初始化httpclient的时候，我使用闭锁，并且使用回调onsuccess后释放闭锁，但是onfail的时候，也就是有异常的时候，我没有释放闭锁，这里漏了一个闭锁的countdown，并且没有给闭锁设置超时时间，至此，所有出现这个异常的请求到这里，清一色全部阻塞住，由于不是所有的请求都出现这个异常，所以过了好长时间才造成的接口不能接受请求，并且线程池满了。</p>
<p>更改代码，特意使用connect refuse的ip进行测试，后面就很快的释放线程了，并且线程池的第二个都没有使用过。:</p>
<p>看来细微决定成败，一个小小的问题机会导致整个应用的效率的快慢。自己平时要多关注这种问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.17号早上大概10点，尝试调用抢票的接口，已经直接返回false，无法查询准确的数据，今天把昨天的日志拽下来（昨天的日志会自动copy到一个ftp目录下面），使用linux命令解压日志文件，我预估计可能是线程池满了，直接溢出了，但是正常情况下，应该不会出现这种问题，况且
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>抢票接口开发问题记录一</title>
    <link href="http://dingran.tk/2017/05/17/%E6%8A%A2%E7%A5%A8%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%80/"/>
    <id>http://dingran.tk/2017/05/17/抢票接口开发问题记录一/</id>
    <published>2017-05-17T10:49:04.000Z</published>
    <updated>2017-05-17T11:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.16号，是途牛的会员日，搭上前端组的紧急上线“快车”，准备发布一次，由于之前的车次缺失，导致有一些客户投诉反馈，正好这次修上去；还有一部分是价格问题，价格添加最后更新时间，如果超过规定时间就再次抓取价格，由于12306的价格也不是一成不变的，遇到特殊的情况还是需要手动处理一下；还有的就是对抢票接口的修改。</p>
<p>抢票接口是我已经更改了好几遍了，上线了好几次，但是每次都是运行一段时间就反馈没有数据了，让我丈二摸不着头脑，这次上线，我对线程池进行了一些改动，并且打印了一些关键日志，能够让我掌握一些重要的参数，5.17号也就是今天，我把昨天的日志拉下来，打开后，排查15点之后的日志，发现了一条记录“插入缓存异常”，我在本地稍微压测了一下发现也报这个异常，于是查看系统的redis连接池，由于使用的事jedis2.1.0还是比较古老的接口了，应用spring-data-redis的jar包进行托管。封装了好多逻辑，我将redis的连接至增大了一倍，但是问题还是没有解决，于是上网搜索一番，更换jedis的redis客户端管理工具，简单方便。首先将jar包升级，然后底层封装改为jedis，原来配置一堆的代码，现在只要几行就搞定了，简单清爽。运行修改了几次后，就可以正常跑起来了。再次调节redis的连接池的大小，这次居然没有任何问题，关键是jedis在每次获取jedis对象，用完后都可以直接finally里面close掉，而spring-data-redis运行多个就会出现获取不到pool的尴尬局面，这是今天的任务一。</p>
<p>在controller接收到其他系统请求后，我采用线程异步处理，主线程使用countdown闭锁等待一定时间，在异步线程采用线程池，我放了两个，判断线程池的启动数目，如果启动数目大于等于总的数目就用第二个线程池，这里面虽然没有和数据库等其他io交互，但是这里有爬取12306，处理结果，拼装结果，也算不上是cpu密集型，可以算是io密集型。之前配置的是cpu密集型，所以在今天拉下来的日志里面，我看到了线程池启动的数目已经到达极限了，今天将线程池的参数重新配置一下，我在本地重新压测，每秒20次查询，发现没有问题，都可以正常运行。</p>
<p>由于线上的环境风云变幻，所以还需要做很多操作。并发接口开发起来就像是在大海航行一样，平时风平浪静，但是一旦请求接踵而至的时候，就会波浪滔天，顷刻就有翻船的事故。所以我这次还是让测试准备进行压测一下，平时对这个接口感觉没有任何困难，但是现在看来，不光是代码的问题，比如redis的连接池、线程池的参数配置以及JVM的相关参数优化都是需要再三考虑的。</p>
<p>互联网公司就是这样，碰到的问题很多，想起了那句话，在互联网公司待一年相当于在其他公司待3年，不光是问题多，成长也很多，收获也很多。</p>
<p>等待下次上线，这次做好相关测试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.16号，是途牛的会员日，搭上前端组的紧急上线“快车”，准备发布一次，由于之前的车次缺失，导致有一些客户投诉反馈，正好这次修上去；还有一部分是价格问题，价格添加最后更新时间，如果超过规定时间就再次抓取价格，由于12306的价格也不是一成不变的，遇到特殊的情况还是需要手动处
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>车次缺失问题排查</title>
    <link href="http://dingran.tk/2017/05/16/%E8%BD%A6%E6%AC%A1%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://dingran.tk/2017/05/16/车次缺失问题排查/</id>
    <published>2017-05-16T02:54:04.000Z</published>
    <updated>2017-05-16T10:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.10上线一版之后，在5.19号听到客户有反馈有些车次没有和12306进行同步，我很好奇，是数据没有抓下来么？还是12306接口返回结果又有什么变化么？</p>
<p>我在本地以及测试环境上查询相关车次均能够正常显示，首先排除了12306返回的结果问题，应该是自己的代码哪里没有处理好，造成车次丢失，可是没有办法正确定位问题。</p>
<p>5.15号团建回来第一天上班，出现了好几单这个问题，有一个Z29的车次映入眼帘，由于只能使用ELK查看日志，不是很方便还有延迟，但是怀着试试的心态，我调用这个接口，赶快查看日志，输入关键字Z29调节时间到最近，搜索，哇塞，出现了，报了一个匹配车次的异常。ok，有异常出现，那么下面就是排查问题了，后面跟着nullpointer，可惜堆栈没有打出来，不过参数打印出来了，根据打印日志找到相关的代码，排查一下，最后定位到是反刷结果的时候出现的问题，在用户成功下单后，会把真的下单结果反刷给dtc，由于算下铺的时候需要用到硬座，但是Z29这种车是没有硬座的，于是出现空指针异常，判断没有判断到位，造成有相关车次的丢失。</p>
<p>于是修改代码，将线上的反刷缓存放到测试redis里面，在用我们自己的程序跑一下，果然报错了，并且丢失了那个车次，于是根据问题，修改代码，修复了这个问题。</p>
<p>最近再彻底重构DTC数据中心的代码，有的地方重构出现没有考虑完整的情况，造成此类问题的发生，希望以后引起注意，勿再发生。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.10上线一版之后，在5.19号听到客户有反馈有些车次没有和12306进行同步，我很好奇，是数据没有抓下来么？还是12306接口返回结果又有什么变化么？&lt;/p&gt;
&lt;p&gt;我在本地以及测试环境上查询相关车次均能够正常显示，首先排除了12306返回的结果问题，应该是自己的代码哪
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>线程池理解误区</title>
    <link href="http://dingran.tk/2017/05/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%90%86%E8%A7%A3%E8%AF%AF%E5%8C%BA/"/>
    <id>http://dingran.tk/2017/05/12/线程池理解误区/</id>
    <published>2017-05-12T10:26:22.000Z</published>
    <updated>2017-05-12T10:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>线程池平时使用的都是很多的，特别是在系统并发的情况下，合理运用线程池就显得特别重要。线程池的参数有以下几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ThreadPoolExecutor mExecutor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,<span class="comment">// 核心线程数  </span></div><div class="line">                        maximumPoolSize, <span class="comment">// 最大线程数  </span></div><div class="line">                        keepAliveTime, <span class="comment">// 闲置线程存活时间  </span></div><div class="line">                        TimeUnit.MILLISECONDS,<span class="comment">// 时间单位  </span></div><div class="line">                        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(),<span class="comment">// 线程队列  </span></div><div class="line">                        Executors.defaultThreadFactory(),<span class="comment">// 线程工厂  </span></div><div class="line">                        <span class="keyword">new</span> AbortPolicy()<span class="comment">// 队列已满,而且当前线程数已经超过最大线程数时的异常处理策略  </span></div><div class="line">                );</div></pre></td></tr></table></figure>
<p>这几个参数都能滚瓜烂熟的记下来，但是也许自己没太注意，学习不到位，我的理解是，线程池启动先启动corePoolSize的线程，超过这个线程就在启动一个，直到maxnumpoolsize,然后后面的再添加线程<br>就直接放到队列里面，但是查看代码却不是这样，随后上网查看相关资料，才恍然大悟，配置线程池要根据这个实际应用情况来定，比如来个请求，我起一个线程，线程池配置24，初始化12个，队列1000，那么就是说当<br>来12个请求后的13个请求就会进入队列，并不会创建第13个线程，就会造成请求超时，没有使线程达到最佳的利用率，所以借此<b>谨记</b>这个问题。</p>
<p>下面为线程池的运行过程：</p>
<ul>
<li><p>如果线程池的状态是RUNNING，线程池的大小小于配置的核心线程数，说明还可以创建新线程，则启动新的线程执行这个任务。</p>
</li>
<li><p>如果线程池的状态是RUNNING ，线程池的大小小于配置的最大线程数，并且任务队列已经满了，说明现有线程已经不能支持当前的任务了，并且线程池还有继续扩充的空间，就可以创建一个新的线程来处理提交的任务。</p>
</li>
<li><p>如果线程池的状态是RUNNING，当前线程池的大小大于等于配置的核心线程数，说明根据配置当前的线程数已经够用，不用创建新线程，只需把任务加入任务队列即可。如果任务队列不满，则提交的任务在任务队列中等待处理；如果任务队列满了则需要考虑是否要扩展线程池的容量。</p>
</li>
<li><p>当线程池已经关闭或者上面的条件都不能满足时，则进行拒绝策略，拒绝策略在RejectedExecutionHandler接口中定义，可以有多种不同的实现。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池平时使用的都是很多的，特别是在系统并发的情况下，合理运用线程池就显得特别重要。线程池的参数有以下几个：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="线程池" scheme="http://dingran.tk/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>途牛5.8号上线回顾</title>
    <link href="http://dingran.tk/2017/05/10/%E9%80%94%E7%89%9B5-8%E5%8F%B7%E4%B8%8A%E7%BA%BF%E5%9B%9E%E9%A1%BE/"/>
    <id>http://dingran.tk/2017/05/10/途牛5-8号上线回顾/</id>
    <published>2017-05-10T09:14:33.000Z</published>
    <updated>2017-05-11T09:59:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.8号，周一，是个上线的日子。本次改动如下：</p>
<ol>
<li>拼装12306返回数据采用多线程处理，本机试验下可提速50%左右</li>
<li>拼装缓存数据返回给前端，采用多线程处理，本机试验下可提速50%</li>
<li>再返回结果后要赋值反刷结果到列表里面，多次循环车次信息表，改动点：在拼装缓存结果的时候直接在多线程里面直接赋值反刷结果。</li>
</ol>
<p>总结：就是讲以前单一的解析数据改为多线程处理，化整为零，能够快速的反馈结果。</p>
<p>但是遗憾的是上线不到20分钟，接口预警界面直接报警，接口调用超时严重，没办法直接回滚代码。在jvisualvm监控线上某台jvm的时候发现这台jvm的线程总数已经达到990+，马上要突破1000了，要知道一台机器的<br>线程数量是有限的，线程是十分宝贵的资源，随便乱用会造成系统访问慢等问题发生，直接打开代码搜索new Thread，发现很多地方用了这个代码，全部改为线程池启动，再次搜索new Thread，发现某个前员工在实现initializingBean<br>的afterPropertiesSet里面创建线程池，各项参数配置的挺好的，为什么就是不放到spring进行托管呢，spring不就是做这件事的么？！没办法，开始将所有这种实现的方式的代码全部改为spring托管线程池<br>问运维人员线上服务器的系统参数，根据参数为每个线程池配置好合理的线程数量，然后再启动tomcat，原来启动需要将近400个线程，现在启动后不到180个，节省了近一半的数量。</p>
<p>然后就是更改代码，代码里面用了闭锁，在countDown.await的时候，添加时间控制，如果规定时间没有返回数据，返回的结果无效。这样不会出现线程出现无限等待的情况。</p>
<p>在使用countDown.countDown()的时候的代码全部用try catch，不管在何时，就算是出现异常，也要保证countDown。</p>
<p>这几天最主要的问题就是价格不准，由于预算紧张，代理ip有限，所以必须保证“好刀用到刀刃上”,在抓取价格的时候，如果某一天的价格已经抓取过一次了，就不再进行抓取了，但是这样会有个问题，就是价格<br>如果是10天之前抓的，但是第九天发现12306涨价了，那么这个价格我就没有办法保证是正确的价格。所以本次修改在每个价格的json后面加入lastUpdateTime，只要保证保证lastUpdateTime和当前时间的<br>差距在可配置的时间内，就不再进行抓取，这样就保证了价格准确性。如果规定时间内12306如果改变价格，可以删除缓存，就可以再重新抓取，根据以往的经验，12306不会随意变更价格，就算变更价格<br>也会在首页上进行公示，可以给我们有充足的时间进行改动，保证价格的准确性能够让用户进行买到火车票。</p>
<p>本次加入“开关”，先进行以前的不使用多线程进行处理，然后全部上线成功后使用多线程处理数据，这样可以统一监控数据。</p>
<p>希望今天上线一次成功。</p>
<hr>
<p>上线一次成功，余位通用接口顺利访问，响应时间也很可观，抢票专用接口刚开始还是很稳定的，但是运行一段时间后，再次发生超时现象预估计为线程池溢出，在一处代码发现bug是自己写代码没注意到整个逻辑，造成抢票接口频繁出现异常，后续已经改正。整个抢票在高并发下问题还有很多，也是自己所有积累的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.8号，周一，是个上线的日子。本次改动如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拼装12306返回数据采用多线程处理，本机试验下可提速50%左右&lt;/li&gt;
&lt;li&gt;拼装缓存数据返回给前端，采用多线程处理，本机试验下可提速50%&lt;/li&gt;
&lt;li&gt;再返回结果后要赋值反刷结果到列表里
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>记途牛火车票数据中心余位接口优化记录</title>
    <link href="http://dingran.tk/2017/05/05/%E8%AE%B0%E9%80%94%E7%89%9B%E7%81%AB%E8%BD%A6%E7%A5%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E4%BD%99%E4%BD%8D%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"/>
    <id>http://dingran.tk/2017/05/05/记途牛火车票数据中心余位接口优化记录/</id>
    <published>2017-05-05T08:23:29.000Z</published>
    <updated>2017-05-05T10:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是5月5号了，距离12306的整改接口整整过去了小半个月，现在数据中心的接口所覆盖&gt;的查询数据已经可以达到之前所有的数据。回头一想，我现在做的工作是有多么的被动，12<br>306抖一抖，我们就要震两三天，没办法，谁让我们是爬取人家的数据呢。</p>
<p>按照新的12306接口提供的数据采用竖线分割的方法获取的数据与之前的对比在效率上是有&gt;很大的差别的，至少从我本机上来看的。本机是公司配的开发机器：双核 8g内存 tomcat给予2g内存 但是改完的接口在我本地没查询一次几乎都不可能在5s内返回结果，也许是我开了其他应用导致的，但是之前相同情况下返回的结果也能在5s以内返回啊，这是有很大的问<br>题的，数据中心余位查询是核心接口，性能太慢了也说不过去了，而且还有很多其他分销商<br>接进来，这么慢不是会让人家吐槽的么。发布到测试环境反应速度还可以2~4秒跑长趟，但<br>是本机还是很慢，所以，还是从我的机器山入手，来查询瓶颈在哪：</p>
<p>找了一个车次 上海-南京 这个一天的车次大概有260个左右 所以就拿这个测，如果这个查询速度快了，那么其他的就会更快了。</p>
<ol>
<li><p>首先判断是否是12306返回的结果时间太长，加上日志，用java自带的毫秒函数来判断发<br>现12306返回的结果（上海-南京）最慢的也在2秒以内，70kb左右，由于使用代理ip可能还会有点耗时，也不会太久，但是我用接口调用用chrome浏览器发起请求到返回总共一共用了<br>20多秒，多以和12306和代理ip返回结果没有多大关系。</p>
</li>
<li><p>是不是拼装12306返回数据很慢呢？同样，打上日志，调用一次接口发现260个车次解析成对象放到list里面，总共耗时15秒左右，嗯，这是一个优化的地方，如何优化呢？我想到<br>使用多线程解析数据，然后将数据放到一个容器中，最后将容器数据返回即可。想法有了，<br>开始做，先创建一个list，然后循环12306返回数据，每拿到一组数据，用线程池发起一个线程去处理，外面用闭锁await，当所有线程都解析完成后，闭锁释放，实现起来也很容易，我先拿抢票接口做实验，调用接口查看时间发现可以在3秒左右返回数据这是相当的快呀，然后将一些没用的字符串去掉，比如string a = “abc”，这种也会创建临时变量的全部拿掉，减少创建对象节省jvm内存；再次相同的办法处理余位接口，拿上海到南京来查询，发现返回数据的速度快了很多，但是到chrome的数据返回时间还是有20多秒，这是怎么回事？</p>
</li>
<li><p>再次判断抢票专用接口和通用余位查询接口为什么这么大差距呢？对比发现抢票接口的缓存数据就是要返回的数据，是我当初就这么设计的，而通用余位查询接口返回的数据格式还需要再次进行改造才能返回前端展示，于是专门看buildCache方法，这个方法每次查询都会调用，包括数据格式的变化，还有价格的反刷的问题，瞬间我就想到价格反刷有问题，查看逻辑，里面会有个向前推得判断方法，现在12306经常一天一个价这种办法已经不太实用了，但是没办法，不能随便改，先打到日志看看处理完花费时间，全部处理完数据总共花了18秒左右，总共胡斐21秒左右，处理这个就花费了近3/4，太奢侈了，这距离我们规定的5秒以内差距太远了，我给每个车次反刷打上日志查看，每个车次处理还算快大概平局60ms左右，但是260*60大概有16秒左右，到这里其实就是单个线程一个一个处理，非常耗时。</p>
</li>
<li><p>找到问题症结了，开始继续采用多线程+闭锁处理，这样其实是多个线程并行，260个车次，在线程池并行处理下不到3秒就处理完了，真爽，发布代码，启动后，调用接口上海-南京，不走缓存，返回时间在3~4秒之间 ，再来个数据上海到北京大概有46个左右车次，不到一秒返回，走缓存就更快了，嗯，终于感受到多线程的快感了。</p>
</li>
<li><p>由于以上都是在我本机测试，所以我要发布到测试环境，提交代码，进行构建后，调用接口，发现上海-南京返回时间在1.2秒左右 ，之前返回还在5秒左右，提高了将近3秒左右，在查上海-北京几乎都是几百毫秒，秒回，加上缓存的作用下，相信后面再线上部署后会更加有效果。</p>
</li>
</ol>
<p>本次优化使用多线程+闭锁，其实没有多大的新意，但是我一直遵守一句话就是：做什么事要有想法，没想法做什么？其实所谓的想法就是经验，经验多了想法当然就多了，在平时平庸的代码里面，加上一些并行操作会让系统跑的更加快。</p>
<p>其中也遇到了很多问题，比如多线程向list里面存放数据的时候就会报concurrentModificationException，是因为迭代的时候发现list的数据个数发生变化就会报这个异常，那么就要解决这个问题，解决办法是copyonwritearraylist和collections.synchronizedList，由于我这边主要是写数据，经过对比查询，synchronizeList比较适合我，copyOnWrite适合读多写少的情况，改完后再也没有报这个异常。                                                  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是5月5号了，距离12306的整改接口整整过去了小半个月，现在数据中心的接口所覆盖&amp;gt;的查询数据已经可以达到之前所有的数据。回头一想，我现在做的工作是有多么的被动，12&lt;br&gt;306抖一抖，我们就要震两三天，没办法，谁让我们是爬取人家的数据呢。&lt;/p&gt;
&lt;p&gt;按照新
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>途牛火车票12306数据中心0426变动记录</title>
    <link href="http://dingran.tk/2017/05/04/%E8%AE%B0%E9%80%94%E7%89%9B%E7%81%AB%E8%BD%A6%E7%A5%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%830426%E5%8F%98%E5%8A%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://dingran.tk/2017/05/04/记途牛火车票数据中心0426变动记录/</id>
    <published>2017-05-04T08:00:47.000Z</published>
    <updated>2017-05-05T07:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我们能达到今天的成就，是因为我们站在巨人的肩膀上</p>
</blockquote>
<p>之前博客都是转发或者摘抄别人的优秀文档，自己很少弄点东西上来，也许是自己没有善于积累的习惯，今天灵机一动，想写点什么！</p>
<p>话说2017年4月26日，是我进途牛的第八个月了，一切过得都还是顺利，虽然每天或多或少会有一些线上的bug之类的问题，但是都不紧急，每天轻车熟路，按部就班。4.27号刚到公司楼下。德良打电话说余位接口查不出数据了，走的全是缓存数据，根据我的想法，查不出数据一共有两个方面1.代理ip封掉了2.服务降级了，我进入公司先查看代理ip情况，一切正常，服务也没有降级。我调用余位接口，发现返回都是昨天的数据。瞬间一股凉意袭上心头，查看12306突然发现返回的数据全部变掉了，造成我们这边“不认识”这是数据格式，没办法紧急和德良黄甲商量后抓紧修改，本来是上线日，所有数据中心的上线计划全部推掉，我开始解析12306返回的数据，之前是有字段标识的，现在全部是“|”分割，幸好之前我保留了一份完整的数据，然后查询相同车次，获取12306返回结果，一个一个对比，正好一共35个字段，问题来了，原来返回40多个，现在只有35个，缺少这么多，有一些还是结果必须要用的比如起售时间，心中暗骂12306不地道，不过想想要是我也不会传送这个字段，略显尴尬，先叫产品停掉预售票，然后开始写代码，瞬时感觉时间过得好快啊，到了下午4点，根据开闭原则，我没有直接修改原来的方法，新创建方法，一遍吐槽老代码写的烂一别提醒自己别干这样的事—老代码先把对象放进map里面，在给对象赋值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pubic void main()&#123;</div><div class="line">Object obj = new Object();</div><div class="line">Map map = new HashMap()'</div><div class="line">map.put("obj",obj);</div><div class="line">obj.set...</div><div class="line">obj.set...</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>艾玛，这不是打破我的认知么，咱不能先创建好对象，赋值之后，在放进map里面，我还以为下面都是没用的数据，这引用传递都玩上天了。</p>
<p>下午4点一刻，第一个版本可以了，自测可以查出数据，兼容老的设计，一切都很妥当，但是就是没有车站开始预售时间啊，没办法，先把数据查出来，毕竟分销商（JD）和boss3打包已经爆炸了，赶快提交测试，经过几轮的bug修复，第一个版本上线了，可以查询12306最新的余位信息，还有一些细节没处理好，等这个版本上完已经晚上了，心好累，早些回去，第二天再收尾。如果按照之前的接口完成的任务量，现在的只完成了之前的60%左右的任务。</p>
<p>第二天4.28号，做了一宿改代码的噩梦后，boss3说我们这边传送的列车经过几天不对，我一查发现和他们的计算方式不对，原来这个字段是12306自己提供的，现在没有了，只能我自己搞了，修修改改可以了，由于之前资源落地的数据有很多是脏数据，导致这些数据要被更新掉，现在ris搜索的接口推送mq更新res，测试发现数据没有更新，我擦，一个接一个的问题啊，查看逻辑没有问题，问题出现在最后的mq的推送的问题，就是推送不过去啊，经过查看插入资源的代码，发现和更新的代码最后殊途同归啊，我擦，插入资源用tsp，更新资源用mq，这是什么道理，我直接将更新资源改用插入的tsp，我了擦，居然直接更新数据，困扰好长时间的问题解决了（这里省略我查找对比插入和更新资源的过程），随后在测试机器进行测试，出发时间，到达时间，售价，随便改，查询后立即更新。就是这么高效，喜欢这种感觉。今天再紧急上线，达到之前接口80%的功能量。</p>
<p>好好休息了一个周末，5.2号来，还差预售时间了，刚开始准备放进db里面，后来考虑还要创建表、查询频率和速率等方面，如果预售时间发生变化，修改起来比较困难，想来先去，还是放入缓存吧，但是缓存需要支持key-value类型，查看项目用的redis太老了，不敢升级，升级报错一堆，没把那只能继续封装原来接口，采用redis的hash的方法，封装了两个接口，数据存进去，起售时间-车站s，ok，完美解决。再封装一个方法，根据车站查询预售时间，就是根据value查找key，恶心的上海的各个站还是预售时间不一致，我擦，没办法，先模糊识别，在精确识别，一套查询袭来耗时也就10毫秒左右，可以忍受。后面比较麻烦的来了，就是算预售时间，通用接口的把预售时间赋值上去，稍微改动没有问题，但是抢票接口的就麻烦了，逻辑不一致，经过多次修改，终于搞定了，很完美。经过这一天的完成，接口终于可以达到之前99%的功能了。</p>
<p>由于12306接口的返回结果变动，改用“|”分割的数据解析，在我本地机器上运行起来很慢，但是在测试服务器上和线上还是很快的，经过打日志发现解析12306返回结果数据相当耗时，所以今天我想采用多线程+闭锁的方式来实现，说干就干，抽取代码，改用线程池+闭锁，实现起来不难，测试抢票接口之前本机上5s都不能返回数据，现在2~4秒以内就可以返回，算是不小的改进，化整为零的思想还是不错的。但是又出现了list的java.util.concurrentModificationException，这个需要细心排查，没有进行remove操作还是会出现，排查中..（让我想起面试EMC的面试官的一道题，就是统计一本书的每个字出现的个数，什么方法都行，当时稚嫩的我如何想到分布式或者多线程呀，想想就汗颜呀）</p>
<p>回想起来，我这一短时间到底在途牛学到了什么，仔细回想其实还是不少的，我新开了一个接口供自己负责的牛抢票用，第一次一段时间后报警了，经过简单排查插入数据库可能频繁访问拖得db很慢，造成查询很慢，去掉后，自上线发现还是很慢，这次准备改为闭锁，之前是用的future.get时间返回，但是很慢，正在改进中。一个接口在正常情况下没问题，但是在高并发下就会凸显一系列问题。</p>
<p>崎岖的路，继续走。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们能达到今天的成就，是因为我们站在巨人的肩膀上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前博客都是转发或者摘抄别人的优秀文档，自己很少弄点东西上来，也许是自己没有善于积累的习惯，今天灵机一动，想写点什么！&lt;/p&gt;
&lt;p&gt;话说2017年4月26
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>spring的bean生命周期</title>
    <link href="http://dingran.tk/2017/04/24/spring%E7%9A%84bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://dingran.tk/2017/04/24/spring的bean生命周期/</id>
    <published>2017-04-24T03:18:37.000Z</published>
    <updated>2017-04-24T03:35:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-bean-的生命周期"><a href="#spring-bean-的生命周期" class="headerlink" title="spring bean 的生命周期"></a>spring bean 的生命周期</h1><p>Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p>
<p> 转载请注明地址 <b><a href="http://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">http://www.cnblogs.com/zrtqsk/p/3735273.html</a></b>，谢谢。</p>
<h2 id="一、生命周期流程图："><a href="#一、生命周期流程图：" class="headerlink" title="一、生命周期流程图："></a>一、生命周期流程图：</h2><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。<br><img src="http://images.cnitblog.com/i/580631/201405/181453414212066.png" alt=""></p>
<p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p>
<h2 id="二、各种接口方法分类"><a href="#二、各种接口方法分类" class="headerlink" title="二、各种接口方法分类"></a>二、各种接口方法分类</h2><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<h3 id="1、Bean自身的方法："><a href="#1、Bean自身的方法：" class="headerlink" title="1、Bean自身的方法："></a>1、Bean自身的方法：</h3><p>这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p>
<h3 id="2、Bean级生命周期接口方法："><a href="#2、Bean级生命周期接口方法：" class="headerlink" title="2、Bean级生命周期接口方法："></a>2、Bean级生命周期接口方法：</h3><p>这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p>
<h3 id="3、容器级生命周期接口方法："><a href="#3、容器级生命周期接口方法：" class="headerlink" title="3、容器级生命周期接口方法："></a>3、容器级生命周期接口方法：</h3><p>这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p>
<h3 id="4、工厂后处理器接口方法："><a href="#4、工厂后处理器接口方法：" class="headerlink" title="4、工厂后处理器接口方法：　　"></a>4、工厂后处理器接口方法：　　</h3><p>这个包括了AspectJWeavingEnabler,ConfigurationClassPostProcessor,CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p>
<h2 id="三、演示"><a href="#三、演示" class="headerlink" title="三、演示"></a>三、演示</h2><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p>
<h3 id="1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法"><a href="#1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法" class="headerlink" title="1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法"></a>1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法</h3><p>为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：</bean></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> qsk</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">BeanNameAware</span>,</span></div><div class="line">        <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String address;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> phone;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</div><div class="line">    <span class="keyword">private</span> String beanName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【构造器】调用Person的构造器实例化"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【注入属性】注入属性name"</span>);</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【注入属性】注入属性address"</span>);</div><div class="line">        <span class="keyword">this</span>.address = address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> phone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(<span class="keyword">int</span> phone)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【注入属性】注入属性phone"</span>);</div><div class="line">        <span class="keyword">this</span>.phone = phone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Person [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", phone="</span></div><div class="line">                + phone + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是BeanFactoryAware接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory arg0)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()"</span>);</div><div class="line">        <span class="keyword">this</span>.beanFactory = arg0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是BeanNameAware接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String arg0)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【BeanNameAware接口】调用BeanNameAware.setBeanName()"</span>);</div><div class="line">        <span class="keyword">this</span>.beanName = arg0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是InitializingBean接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"【InitializingBean接口】调用InitializingBean.afterPropertiesSet()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是DiposibleBean接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【DiposibleBean接口】调用DiposibleBean.destory()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestory</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、接下来是演示BeanPostProcessor接口的方法，如下："><a href="#2、接下来是演示BeanPostProcessor接口的方法，如下：" class="headerlink" title="2、接下来是演示BeanPostProcessor接口的方法，如下："></a>2、接下来是演示BeanPostProcessor接口的方法，如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out.println(<span class="string">"这是BeanPostProcessor实现类构造器！！"</span>);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object arg0, String arg1)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">        .println(<span class="string">"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！"</span>);</div><div class="line">        <span class="keyword">return</span> arg0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object arg0, String arg1)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">        .println(<span class="string">"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！"</span>);</div><div class="line">        <span class="keyword">return</span> arg0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，BeanPostProcessor接口包括2个方法postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</p>
<h3 id="3、InstantiationAwareBeanPostProcessor-接口本质是BeanPostProcessor的子接口"><a href="#3、InstantiationAwareBeanPostProcessor-接口本质是BeanPostProcessor的子接口" class="headerlink" title="3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口"></a>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口</h3><p>，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span></span></div><div class="line">        <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接口方法、实例化Bean之前调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class beanClass,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接口方法、实例化Bean之后调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接口方法、设置某个属性时调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs,</span></span></div><div class="line">            PropertyDescriptor[] pds, Object bean, String beanName)</div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法"</span>);</div><div class="line">        <span class="keyword">return</span> pvs;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</p>
<h3 id="4、演示工厂后处理器接口方法，如下："><a href="#4、演示工厂后处理器接口方法，如下：" class="headerlink" title="4、演示工厂后处理器接口方法，如下："></a>4、演示工厂后处理器接口方法，如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out.println(<span class="string">"这是BeanFactoryPostProcessor实现类构造器！！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory arg0)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"BeanFactoryPostProcessor调用postProcessBeanFactory方法"</span>);</div><div class="line">        BeanDefinition bd = arg0.getBeanDefinition(<span class="string">"person"</span>);</div><div class="line">        bd.getPropertyValues().addPropertyValue(<span class="string">"phone"</span>, <span class="string">"110"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5、配置文件如下beans-xml，很简单，使用ApplicationContext-处理器不用手动注册："><a href="#5、配置文件如下beans-xml，很简单，使用ApplicationContext-处理器不用手动注册：" class="headerlink" title="5、配置文件如下beans.xml，很简单，使用ApplicationContext,处理器不用手动注册："></a>5、配置文件如下beans.xml，很简单，使用ApplicationContext,处理器不用手动注册：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">            http://www.springframework.org/schema/beans </div><div class="line">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instantiationAwareBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyInstantiationAwareBeanPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactoryPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanFactoryPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInit"</span></span></div><div class="line">        <span class="attr">destroy-method</span>=<span class="string">"myDestory"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">p:name</span>=<span class="string">"张三"</span> <span class="attr">p:address</span>=<span class="string">"广州"</span></div><div class="line">        <span class="attr">p:phone</span>=<span class="string">"15900000000"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="6、下面测试一下："><a href="#6、下面测试一下：" class="headerlink" title="6、下面测试一下："></a>6、下面测试一下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLifeCycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"现在开始初始化容器"</span>);</div><div class="line">        </div><div class="line">        ApplicationContext factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"springBeanTest/beans.xml"</span>);</div><div class="line">        System.out.println(<span class="string">"容器初始化成功"</span>);    </div><div class="line">        <span class="comment">//得到Preson，并使用</span></div><div class="line">        Person person = factory.getBean(<span class="string">"person"</span>,Person.class);</div><div class="line">        System.out.println(person);</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"现在开始关闭容器！"</span>);</div><div class="line">        ((ClassPathXmlApplicationContext)factory).registerShutdownHook();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关闭容器使用的是实际是AbstractApplicationContext的钩子方法。"><a href="#关闭容器使用的是实际是AbstractApplicationContext的钩子方法。" class="headerlink" title="关闭容器使用的是实际是AbstractApplicationContext的钩子方法。"></a>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</h3><p>我们来看一下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">现在开始初始化容器</div><div class="line">2014-5-18 15:46:20 org.springframework.context.support.AbstractApplicationContext prepareRefresh</div><div class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19a0c7c: startup date [Sun May 18 15:46:20 CST 2014]; root of context hierarchy</div><div class="line">2014-5-18 15:46:20 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</div><div class="line">信息: Loading XML bean definitions from class path resource [springBeanTest/beans.xml]</div><div class="line">这是BeanFactoryPostProcessor实现类构造器！！</div><div class="line">BeanFactoryPostProcessor调用postProcessBeanFactory方法</div><div class="line">这是BeanPostProcessor实现类构造器！！</div><div class="line">这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！</div><div class="line">2014-5-18 15:46:20 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons</div><div class="line">信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9934d4: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法</div><div class="line">【构造器】调用Person的构造器实例化</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法</div><div class="line">【注入属性】注入属性address</div><div class="line">【注入属性】注入属性name</div><div class="line">【注入属性】注入属性phone</div><div class="line">【BeanNameAware接口】调用BeanNameAware.setBeanName()</div><div class="line">【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()</div><div class="line">BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！</div><div class="line">【InitializingBean接口】调用InitializingBean.afterPropertiesSet()</div><div class="line">【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法</div><div class="line">BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法</div><div class="line">容器初始化成功</div><div class="line">Person [address=广州, name=张三, phone=110]</div><div class="line">现在开始关闭容器！</div><div class="line">【DiposibleBean接口】调用DiposibleBean.destory()</div><div class="line">【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法</div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>————————如果觉得本博文还行，别忘了推荐一下哦，谢谢！</li>
<li>作者：钱书康</li>
<li>欢迎转载，请保留此段声明。</li>
<li>出处：<a href="http://www.cnblogs.com/zrtqsk/" target="_blank" rel="external">http://www.cnblogs.com/zrtqsk/</a><br>*/</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-bean-的生命周期&quot;&gt;&lt;a href=&quot;#spring-bean-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;spring bean 的生命周期&quot;&gt;&lt;/a&gt;spring bean 的生命周期&lt;/h1&gt;&lt;p&gt;Spring作为当前
    
    </summary>
    
      <category term="spring" scheme="http://dingran.tk/categories/spring/"/>
    
    
      <category term="spring" scheme="http://dingran.tk/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的if使用</title>
    <link href="http://dingran.tk/2017/04/19/mysql%E4%B8%AD%E7%9A%84if%E4%BD%BF%E7%94%A8/"/>
    <id>http://dingran.tk/2017/04/19/mysql中的if使用/</id>
    <published>2017-04-19T06:05:22.000Z</published>
    <updated>2017-04-19T06:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>mysql中的if用法：</p>
<ul>
<li>一种是我们经常使用的case when</li>
<li>还有一种是mysql本身自带函数 if(exp1,exp2,exp3)</li>
</ul>
<p>用法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">select</span> <span class="keyword">if</span>(<span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">is</span> <span class="literal">null</span>,<span class="number">1</span>,<span class="keyword">max</span>(<span class="keyword">id</span>)+<span class="number">1</span>) <span class="keyword">from</span> <span class="keyword">table</span></div><div class="line">#描述为如果<span class="keyword">id</span>最大值是<span class="literal">null</span>，就为<span class="number">1</span>，如果最大<span class="keyword">id</span>不为<span class="literal">null</span>，就将最大<span class="keyword">id</span>加<span class="number">1</span></div></pre></td></tr></table></figure>
<p>可以用来进行一些简单的转换<br>mybatis推荐使用typehandler</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql中的if用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是我们经常使用的case when&lt;/li&gt;
&lt;li&gt;还有一种是mysql本身自带函数 if(exp1,exp2,exp3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlig
    
    </summary>
    
      <category term="数据库" scheme="http://dingran.tk/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://dingran.tk/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>伪共享，并发编程无声的性能杀手</title>
    <link href="http://dingran.tk/2017/04/19/%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%97%A0%E5%A3%B0%E7%9A%84%E6%80%A7%E8%83%BD%E6%9D%80%E6%89%8B/"/>
    <id>http://dingran.tk/2017/04/19/伪共享，并发编程无声的性能杀手/</id>
    <published>2017-04-19T03:43:03.000Z</published>
    <updated>2017-04-19T03:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>伪共享，并发编程无声的性能杀手</p>
</blockquote>
<p>原文链接：<a href="http://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="external">伪共享，并发编程无声的性能杀手</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;伪共享，并发编程无声的性能杀手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.cnblogs.com/cyfonly/p/5800758.html&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
      <category term="并发" scheme="http://dingran.tk/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://dingran.tk/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
