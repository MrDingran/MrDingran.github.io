<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>崎岖的路,走出自己的脚步</title>
  <subtitle>崎岖的路,走出自己的脚步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dingran.tk/"/>
  <updated>2017-06-23T07:29:21.000Z</updated>
  <id>http://dingran.tk/</id>
  
  <author>
    <name>D.R</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集成爬虫到DTC系统以及相关问题总结</title>
    <link href="http://dingran.tk/2017/06/23/%E9%9B%86%E6%88%90%E7%88%AC%E8%99%AB%E5%88%B0DTC%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/06/23/集成爬虫到DTC系统以及相关问题总结/</id>
    <published>2017-06-23T07:16:58.000Z</published>
    <updated>2017-06-23T07:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>6.21号，我把带有爬取免费代理ip的爬虫放到线上，结果部署完成后发现redis不停的报一个错–unexpected stream。上网搜了一下，大概都是缓存空间不够或者多个线程一起调用的问题，但是我觉得用起来根不是这些问题。在测试环境都没有发现这种问题。后来请教运维相关人员瞬间我知道自己出现的问题在哪了。</p>
<p>在代码里面，我使用brpop命令来进行监听某个redis队列是否有数据，类似java的blockingqueue，我之前满心欢喜，这个功能真的好用，但是到了线上就完犊子了，原因是我们线上的redis使用的twemproxy这个twitter的redis代理来进行redis的管理。这个twemproxy可以自动剔除坏掉的节点，比较好用，但是它也有它的缺点就是它不支持一些redis的命令，brpop是其中一个，还有订阅发布等都不支持。有点沮丧，没办法，只能自己去实现这功能了。</p>
<p>昨天6.22号又紧急上线了，我是搭车上线主要是修复一些小问题，顺便把redis这个brpop这个修改了。然后再次发布，到线上后一切正常，然后到了今天早上，我来的时候突然发现dtc系统不提供服务了，经过visualvm链接线上的jvm查看，看见线程活跃说已经达到2800+了，我知道是自己在代码里面创建了一个线程池频繁销毁启动造成的，还好自己做了开关，我将开关关闭，将每台服务器都启动了一遍，多有实例都可以提供服务，没有问题。再看代码再将销毁线程池的地方再次修改，等待下次上线日。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6.21号，我把带有爬取免费代理ip的爬虫放到线上，结果部署完成后发现redis不停的报一个错–unexpected stream。上网搜了一下，大概都是缓存空间不够或者多个线程一起调用的问题，但是我觉得用起来根不是这些问题。在测试环境都没有发现这种问题。后来请教运维相关人
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>DTC集成智能小爬虫抓取免费ip</title>
    <link href="http://dingran.tk/2017/06/18/DTC%E9%9B%86%E6%88%90%E6%99%BA%E8%83%BD%E5%B0%8F%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%85%8D%E8%B4%B9ip/"/>
    <id>http://dingran.tk/2017/06/18/DTC集成智能小爬虫抓取免费ip/</id>
    <published>2017-06-17T16:40:05.000Z</published>
    <updated>2017-06-17T17:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>6.18，年中了，自己马上就要在途牛干了将近1年了，回头望来感慨万千。哎，华奥司机是不是走的有点早啊，再呆上3个月，可能比你之前呆的那一年经历的坑还多呢。</p>
<p>已经是深夜，今天还是父亲节，今天早上起来得给父亲打个电话，谁让我是个大孝子呢，哎没办法。没事写写博客回忆今天做的事情也是蛮快乐的事情呀。</p>
<p>这两天是京东618的日子，每个组都需要有个人值班，虽说我不是这个值班的人，但是我还是本着“工（赚）作（加）至（班）上（费）”的原则还是不请自来了，既然来了也要必须做点事情呀，谁让我的价值观这么高呢。扯远了开始正题：</p>
<p>我先在自己的机器上搭建了一个小java工程，这个工程主要是用来爬取网上的免费代理ip，这一段时间以来12306几乎把我们所有的代理ip全部封掉了，即使买一些新的上去，最多几分钟就挂了，所以我需要一些炮灰来帮我刷新一些数据。由于代理ip不够用了，幸亏之前上了APP反刷（不是火车票列表反刷），之前不看好的功能现在居然成了主力，如果这个功能不上的话，也许数据中心真就直接倒闭了。但是由于查询量太大，app反刷也有些扛不住了，不得已走缓存了，所以数据准确性还真的有待提升。但是这只是个临时的策略，代理ip还是必须得上，否则数据的准确度绝对达不到的。</p>
<p>我把代理的逻辑仔细排查了一下（都看了860遍了，谁写破B玩应），发现了代理ip耗时最多的地方就是价格抓取和经停站的抓取，一次简单的查询，到了后面异步抓取了N多数据，所以代理ip消耗很大，所以有了我之前写的小智能爬虫。</p>
<p>这个爬虫很简单，就是不停的分析页面，抓取有效的信息，不能抓取的过快，否则也有会被封的危险。我在本机上跑的时候很短时间轻松抓取3~5w的代理ip，量很大，但是都需要check，check是最费时的，这么多抓来的ip靠线程池check真是太慢了，我在本机上起了2000+线程直接报错不能在创建线程了，虽然check的慢，但是还是有很多可以用的，中午有一阵居然可以获取2000+的有效代理ip，平时的话也就500左右。</p>
<p>我当初想在本地跑程序，将check后的代理ip放给线上，后来发现本地check太慢，而且不够灵活，我需要随时能够抓取发往线上，线上消耗这个代理ip的速度太惊人了，几乎放上去瞬间就被用光了，所以我还是决定将这个spider集成到dtg里面，作为一个独立的模块，添加定时任务，跑的时候，将没有check的ip用redis队列push进去，由于线上有很多实例，所以我在每个实例上进行监听这个队列，有数据在pop出来，pop500到本地，然后不够500在pop，本地就check数据，这样通过集群的话，check代理ip效率会更高，否则抓取的这么多的代理ip check不完就浪费了。check的时候用线程池，这个都会想到，但是check这个代理ip可能会花费很长时间，什么意思呢？就是线程池会满，如果到了下次触发抓取的时候，继续check这么下去，线程池不崩溃才怪呢。所以我尝试了好多方法，终于找到了一种每次触发都重新创建线程池，之前没处理的线程池直接shutdown掉，给后来的让位置，加上使用单例模式跑起来几乎没有什么问题。我在本地测试，启动在190个线程左右，开始check的时候线程飙到400左右，shutdown后落回200左右，然后定时再触发，再次回到400，这样往复，没错虽然可能会消耗很多资源，但是总起评价来还是值得的。</p>
<p>今天算是把代理集成起来，争取下周上线，后面再把统计抓取免费代理ip数量，check后的数量，真正使用的数量每隔半个小时统计出来，发到我的邮箱。这样可以给黄甲看看当初他看不起的免费代理ip到底支起了多大的天空。</p>
<p>困了，不早了，就到这里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6.18，年中了，自己马上就要在途牛干了将近1年了，回头望来感慨万千。哎，华奥司机是不是走的有点早啊，再呆上3个月，可能比你之前呆的那一年经历的坑还多呢。&lt;/p&gt;
&lt;p&gt;已经是深夜，今天还是父亲节，今天早上起来得给父亲打个电话，谁让我是个大孝子呢，哎没办法。没事写写博客回忆
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>12306app抓包</title>
    <link href="http://dingran.tk/2017/06/11/12306app%E6%8A%93%E5%8C%85/"/>
    <id>http://dingran.tk/2017/06/11/12306app抓包/</id>
    <published>2017-06-11T05:24:33.000Z</published>
    <updated>2017-06-11T05:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直有个想法就是想抓取app上面的访问方式，昨天在网上搜索后发现app可以通过fiddler来抓包，可惜的是fiddler在mac上面不是很友好，今天来到公司，用自己的工作电脑搭建了一个fiddler，网上教程一大把，随便找了一个，按照教程配置好后，将自己的手机连上局域网，打开手机app 就可以抓包了，很简单。</p>
<p>我主要是抓取12306app的余位查询，经过抓包后，我发现参数基本没有什么变化，但是多了几个，比如checkcode等，返回的信息是加密后的乱码，我的心这个凉呀，没办法了，因为我解密不了，还是要请教其他人了，看看能否解密。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直有个想法就是想抓取app上面的访问方式，昨天在网上搜索后发现app可以通过fiddler来抓包，可惜的是fiddler在mac上面不是很友好，今天来到公司，用自己的工作电脑搭建了一个fiddler，网上教程一大把，随便找了一个，按照教程配置好后，将自己的手机连上局域网，
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>Rx_java</title>
    <link href="http://dingran.tk/2017/06/03/Rx-java/"/>
    <id>http://dingran.tk/2017/06/03/Rx-java/</id>
    <published>2017-06-03T02:29:22.000Z</published>
    <updated>2017-06-03T08:05:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rxJava是什么"><a href="#rxJava是什么" class="headerlink" title="rxJava是什么"></a>rxJava是什么</h1><blockquote>
<p>a library for composing asynchronous and event-based programs using observable sequences for the Java VM</p>
</blockquote>
<p>一个对于构成使用的Java虚拟机观察序列异步和基于事件的程序库</p>
<p>github：<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">https://github.com/ReactiveX/RxJava</a></p>
<p>详细信息可以参考：</p>
<p><a href="http://www.oschina.net/p/rxjava" target="_blank" rel="external">http://www.oschina.net/p/rxjava</a></p>
<p><a href="http://www.jianshu.com/p/845549ac4623" target="_blank" rel="external">http://www.jianshu.com/p/845549ac4623</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;rxJava是什么&quot;&gt;&lt;a href=&quot;#rxJava是什么&quot; class=&quot;headerlink&quot; title=&quot;rxJava是什么&quot;&gt;&lt;/a&gt;rxJava是什么&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;a library for composing async
    
    </summary>
    
      <category term="java" scheme="http://dingran.tk/categories/java/"/>
    
    
      <category term="java" scheme="http://dingran.tk/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>APP反刷余位信息上线</title>
    <link href="http://dingran.tk/2017/06/02/APP%E5%8F%8D%E5%88%B7%E7%81%AB%E8%BD%A6%E7%A5%A8%E4%BD%99%E4%BD%8D%E4%BF%A1%E6%81%AF%E4%B8%8A%E7%BA%BF/"/>
    <id>http://dingran.tk/2017/06/02/APP反刷火车票余位信息上线/</id>
    <published>2017-06-02T07:33:58.000Z</published>
    <updated>2017-06-02T08:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>说起app反刷的功能，在火车票数据中心有两个：</p>
<p>第一个是在查询的火车票列表的时候进行反刷12306的余位信息给我们，由于我们的代理ip是有限的，不是每个请求都能分配到代理ip，故而这种情况再返回缓存的时候如果缓存过期就让app去12306获取余位信息，将最新余位信息刷给我们，我们组装信息再返回给前端。最终效果不是很好，会出现卡顿的效果暂时关闭状态。</p>
<p>还有一个app反刷，也是用来处理余位更新的。也是为了节省代理ip，原理就是在手机端开启个线程，每隔一段时间去数据中心访问是否有数据需要抓取。而数据中心这边在代理ip不足的情况下，便需要将抓取的url放进队列里面，手机端的请求每次都从队列里面取数据，这样如果手机端取到数据就直接去访问12306，然后再将获取的结果发送给数据中心，整个流程下来需要在5秒以内完成。</p>
<p>整个反刷功能已经开发好一段时间了，由于现在请求量也不是很大，所以这个功能一直没有开启。最近6.1号开始卖学生票了，由于成人票和学生票是两个接口，代理ip在抓取学生票的时候出现大量被封的现象，被封率达到99%；由于成人票和学生票的代理ip使用逻辑是一套的，这样不仅影响学生票售卖，还影响成人票的售卖。由于学生票接口开始被封，最近又开始卖学生票，没办法只能先将学生票的接口走成人票接口。</p>
<p>走成人票接口只是权宜之计，首先我想先买一批代理ip，从中测试学生票接口能够用的拿出来，其他的给成人票使用，但是询问后得知代理不能够先测试使用，如果买了50个代理ip能够使用的只有40个话，那就亏大了。我爬取ip的小爬虫也写好了但是抓取了3W+的ip能够使用的也就400~500个，关键是不够稳定，放到测试环境还是可以的，放到线上根本不行，于是我想起了app反刷。</p>
<p>稍微修改一下代码，将学生票全部切到app反刷，上线后，我测试了一下，效果不是很好，经常出现查询为空的现象而且再次加载还是为空。经过排查，是我在放入队列的时候做了限制，一个站战对团期只能放入一次，是我想的太多了，因为不是每个放入的数据都能返回来的，去掉这个限制，再次在sit环境测试，效果还不是很好，和前端一起排查，经过推敲分析，发现放入队列的数据，前端查询12306的时候也会出现返回为空的现象。后来前端提醒我可以多放入队列两次，我瞬间豁然开朗，怎么没想到呢？因为线上不是每个人的手机都网速畅通的，有可能像花生地铁这种比较low的，我多放入两次就可以有几率被网速相对好一点的取走，快速返回结果，就会更快返回火车票列表数据。</p>
<p>再次修改代码，将放入队列次数配置在diamond，先配置3次，重新打包。在前端和测试的共同验证下，放进3个，取走3个，查询成功的只有1一个返回，我这边的列表也显示正常，这就看出来不是每次请求都成功，失败率还是挺高的。今天有紧急上线，于是我搭上这趟快车，将代码上线。上线完成后我将配置改为4次，加大查询效率。在app端查询学生票，显示效果还不错，也会出现查询不出来的情况，但是再刷一次就出来了，还可以接受。</p>
<p>app反刷这个功能能够实现，前提是必须有大量的请求才能实现，我监控了一段时间发现这段时间请求量大平稳可以使用，也可算是个小小的里程碑。学生票使用这个功能算是告一段落，后面还要接入成人票。</p>
<p>回头再看这个学生票的解决，内心坎坷呀，由于产品催的紧还和产品小吵了一下，说到底还是自己太浮躁，脾气咋这么大腻？也是自己要好好反思的地方。还好产品心胸开阔，不和我见识，还请我喝奶茶（应该是我请人家啦），实在让我无地自容。这次也算是给自己积累了一些经验，能够在后面乃至将来的工作中应对各种问题更加自如。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起app反刷的功能，在火车票数据中心有两个：&lt;/p&gt;
&lt;p&gt;第一个是在查询的火车票列表的时候进行反刷12306的余位信息给我们，由于我们的代理ip是有限的，不是每个请求都能分配到代理ip，故而这种情况再返回缓存的时候如果缓存过期就让app去12306获取余位信息，将最新余
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>工作总结</title>
    <link href="http://dingran.tk/2017/05/24/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/05/24/工作总结/</id>
    <published>2017-05-24T03:27:30.000Z</published>
    <updated>2017-05-24T04:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>从过年到现在过去了三个月，这段时间可能是我入职途牛以来干的事情最有成果，也是自己最有收获的几个月。这几月熟悉的老司机一个一个离开，自己的身上的单子也越来越重，12306也不省心，三天两头的变动接口，最近还更换了接口的返回数据结构。</p>
<p>这段时间里面，主要是负责数据中心的DTC系统的改造，原来负责的牛抢票业务跟着迭代走就可以了，抢票也几乎没什么需求，但是dtc的问题太多了，急需整改，经过了三个月的整改，主要以下的成果：</p>
<ul>
<li><p>DTC的接口响应时间由原来的3秒左右提高到1.5秒以内，大部分车辆几百毫秒，向上海到南京有260+的车辆，响应时间也在1秒左右。</p>
</li>
<li><p>DTC价格问题抓取不准确，经过整改，价格每天抓取一次，价格带有新鲜度，超过新鲜度会再次出发抓取，每天的价格必须要有。</p>
</li>
<li><p>缓存插入失败问题，这个是我意外查到的每天大概有上千次插入缓存失败，经过排查是获取不到连接池，并且jar包太古老。升级完jar包后，适量增大redis连接池，现在已经没有插入缓存失败的问题。</p>
</li>
<li><p>JVM堆区不正常的偏大GC频繁。我经常用jvisualvm监控线上jvm情况，发现jvm堆有点大，快要溢出了，打了dump后，用eclipse的分析工具发现，在某个代码里面有个全局queue，不断往里面放数据，消费者却很慢，造成数据成倍增加。改造完成后，queue里面的数据几乎很快被消费掉，再次监控jvm堆得数据也恢复了正常水平。</p>
</li>
<li><p>DTC增加抢票专用接口 其实这个接口就是只查询余位信息，不查价格的接口。余位监控只关注是否有余位。这样可以节省很多代理ip的消耗问题。这个接口并发量比较大，一天的查询量平时大概几百万，春运期间大概有上千万的查询量。</p>
</li>
<li><p>线程池的使用问题。平时对配置线程池的参数没有什么概念，但是现在发现配置线程池参数很重要。经过合理配置，系统的线程由原来启动1000+降到现在500左右，没有出现问题。</p>
</li>
</ul>
<p>这段时间有的时候很是折磨，但是看到现在系统平稳运行，心理还是十分高兴地。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从过年到现在过去了三个月，这段时间可能是我入职途牛以来干的事情最有成果，也是自己最有收获的几个月。这几月熟悉的老司机一个一个离开，自己的身上的单子也越来越重，12306也不省心，三天两头的变动接口，最近还更换了接口的返回数据结构。&lt;/p&gt;
&lt;p&gt;这段时间里面，主要是负责数据
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>搭建代理ip仓库想法</title>
    <link href="http://dingran.tk/2017/05/20/%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86ip%E4%BB%93%E5%BA%93%E6%83%B3%E6%B3%95/"/>
    <id>http://dingran.tk/2017/05/20/搭建代理ip仓库想法/</id>
    <published>2017-05-20T02:42:01.000Z</published>
    <updated>2017-05-20T03:31:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.20号周六，今天来到公司来加班，公司的环境比较好，既可以学习，又可以做剩下的工作，还可以拿加班费^_^</p>
<p>刚才打了那么多字，可恶的ultraEdit退出了，还没保存！！</p>
<p>途牛火车票的盈利点很简单，至少我是这么认为的，就是在乘客购买火车票的时候能够购买保险，但是总起计算下来客户购买保险所占的比例还是不高的。但是火车票部门每个月的花费还是多的，这里面有一项就是代理ip的费用。</p>
<p>由于12306会不定时对过于频繁访问的用户进行限制，但是超过一定的限制，这种访问的限制有可能是长期的，所以我们在抓取12306信息的时候都会使用代理ip，模拟多客户端多用户访问12306，让12306不能够轻易的屏蔽我们，我们这边控制好代理ip的使用频率，平时应该没有什么问题，但是常在河边走，哪能不湿鞋，碰到流量大的时候，也会有几个代理ip被屏蔽的现象。</p>
<p>代理ip的费用还是蛮贵的，有阿里云、京东等供应商，价格也都在几十块一个月不等。途牛火车票在平时购买车票不多的情况下，也需要几百个代理ip，遇到春运的时候购买上千个也不在话下。所以代理ip的费用占途牛火车票每个月的预算的大部分了。如果代理ip十分好用也就不说了，但是不是每个代理ip都是十分高效抓取数据，这让我十分头疼，比如昨天的学生票接口使用代理ip就死活访问不了，几乎全军覆没，而成人票接口就没有问题。可能说和代理ip没有关系，但是在本地就是可以的，或者我换用其他新鲜的代理ip就是可以的。</p>
<p>由于以上的原因，我萌生了一个想法，搭建代理ip的仓库。网上有很多的免费的代理ip，没错有很多代理ip是不能用的，但是数量多呀，有一万个，1%能用也是不错的，我准备分为两步走：</p>
<p>第一步：先固定抓取一部分页面，获取代理ip，先测试成功率能够有多少</p>
<p>第二步：直接使用搜索引擎（百度和谷歌）然后利用搜索引擎返回的url再次进行爬取，获取页面里面的代理ip，说到底就是做个智能爬虫，能够解析页面抓取ip</p>
<p>美好的想法肯定有对应的目标：</p>
<ul>
<li><p>满足自己数据中心抓取12306代理ip的使用</p>
</li>
<li><p>满足自己后，就可以给公司其他使用代理ip部门提供代理ip，比如机票等</p>
</li>
<li><p>公司满足后，就可以向外出售动态代理ip（太长远了）</p>
</li>
</ul>
<p>想法是付诸于实现的基石，我很高兴自己有这种想法，而不是浑浑噩噩的做着开发，因为我不是一个满足现状的人，我渴望有fresh的idea来充实自己，让自己的脑细胞尽量更多使用起来，而不是在那等死，即使那会让我很困。（学习新知识会让人疲倦厌恶摒弃）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.20号周六，今天来到公司来加班，公司的环境比较好，既可以学习，又可以做剩下的工作，还可以拿加班费^_^&lt;/p&gt;
&lt;p&gt;刚才打了那么多字，可恶的ultraEdit退出了，还没保存！！&lt;/p&gt;
&lt;p&gt;途牛火车票的盈利点很简单，至少我是这么认为的，就是在乘客购买火车票的时候能
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>抢票接口并发问题记录二</title>
    <link href="http://dingran.tk/2017/05/18/%E6%8A%A2%E7%A5%A8%E6%8E%A5%E5%8F%A3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%BA%8C/"/>
    <id>http://dingran.tk/2017/05/18/抢票接口并发问题记录二/</id>
    <published>2017-05-18T06:55:43.000Z</published>
    <updated>2017-05-18T07:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.17号早上大概10点，尝试调用抢票的接口，已经直接返回false，无法查询准确的数据，今天把昨天的日志拽下来（昨天的日志会自动copy到一个ftp目录下面），使用linux命令解压日志文件，我预估计可能是线程池满了，直接溢出了，但是正常情况下，应该不会出现这种问题，况且我使用2个线程池，在切换线程池的时候，我还打印了一部分日志—打印线程池的一些参数.经过排查日志，发现在早上6点的时候，第一个线程池已经满了，所有的请求已经递交到第二个线程池了，到了9点左右，第二个线程池也满了，所有后续的请求就直接放不进线程池，就直接丢弃报异常。下面try catch捕捉异常直接反馈前端查询失败。</p>
<p>解决办法：刚开始打算是准备给线程配置超时时间，如果线程超过了配置时间就强制停掉，但是后来想线程不是想停就停的，也就说线程启动了不是很听话的。又想增大线程池，但是上网看到一句话，让我豁然开朗，“没有找到线程阻塞的原因，就是放再大的线程池，线程池迟早会满”，就是时间的问题。看来还是自己的代码写的有问题。不找到根本问题，接口无法在高并发下提供服务。</p>
<p>但是回头来想，所有相关接口的地方，我都已经做好控制了，不会出现线程阻塞的情况呀，一行一行看代码，结合日志我终于发现了一个异常点：由于代理ip的问题，可能会出现connect refuse的情况，在初始化httpclient的时候，我使用闭锁，并且使用回调onsuccess后释放闭锁，但是onfail的时候，也就是有异常的时候，我没有释放闭锁，这里漏了一个闭锁的countdown，并且没有给闭锁设置超时时间，至此，所有出现这个异常的请求到这里，清一色全部阻塞住，由于不是所有的请求都出现这个异常，所以过了好长时间才造成的接口不能接受请求，并且线程池满了。</p>
<p>更改代码，特意使用connect refuse的ip进行测试，后面就很快的释放线程了，并且线程池的第二个都没有使用过。:</p>
<p>看来细微决定成败，一个小小的问题机会导致整个应用的效率的快慢。自己平时要多关注这种问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.17号早上大概10点，尝试调用抢票的接口，已经直接返回false，无法查询准确的数据，今天把昨天的日志拽下来（昨天的日志会自动copy到一个ftp目录下面），使用linux命令解压日志文件，我预估计可能是线程池满了，直接溢出了，但是正常情况下，应该不会出现这种问题，况且
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>抢票接口开发问题记录一</title>
    <link href="http://dingran.tk/2017/05/17/%E6%8A%A2%E7%A5%A8%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E4%B8%80/"/>
    <id>http://dingran.tk/2017/05/17/抢票接口开发问题记录一/</id>
    <published>2017-05-17T10:49:04.000Z</published>
    <updated>2017-05-17T11:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.16号，是途牛的会员日，搭上前端组的紧急上线“快车”，准备发布一次，由于之前的车次缺失，导致有一些客户投诉反馈，正好这次修上去；还有一部分是价格问题，价格添加最后更新时间，如果超过规定时间就再次抓取价格，由于12306的价格也不是一成不变的，遇到特殊的情况还是需要手动处理一下；还有的就是对抢票接口的修改。</p>
<p>抢票接口是我已经更改了好几遍了，上线了好几次，但是每次都是运行一段时间就反馈没有数据了，让我丈二摸不着头脑，这次上线，我对线程池进行了一些改动，并且打印了一些关键日志，能够让我掌握一些重要的参数，5.17号也就是今天，我把昨天的日志拉下来，打开后，排查15点之后的日志，发现了一条记录“插入缓存异常”，我在本地稍微压测了一下发现也报这个异常，于是查看系统的redis连接池，由于使用的事jedis2.1.0还是比较古老的接口了，应用spring-data-redis的jar包进行托管。封装了好多逻辑，我将redis的连接至增大了一倍，但是问题还是没有解决，于是上网搜索一番，更换jedis的redis客户端管理工具，简单方便。首先将jar包升级，然后底层封装改为jedis，原来配置一堆的代码，现在只要几行就搞定了，简单清爽。运行修改了几次后，就可以正常跑起来了。再次调节redis的连接池的大小，这次居然没有任何问题，关键是jedis在每次获取jedis对象，用完后都可以直接finally里面close掉，而spring-data-redis运行多个就会出现获取不到pool的尴尬局面，这是今天的任务一。</p>
<p>在controller接收到其他系统请求后，我采用线程异步处理，主线程使用countdown闭锁等待一定时间，在异步线程采用线程池，我放了两个，判断线程池的启动数目，如果启动数目大于等于总的数目就用第二个线程池，这里面虽然没有和数据库等其他io交互，但是这里有爬取12306，处理结果，拼装结果，也算不上是cpu密集型，可以算是io密集型。之前配置的是cpu密集型，所以在今天拉下来的日志里面，我看到了线程池启动的数目已经到达极限了，今天将线程池的参数重新配置一下，我在本地重新压测，每秒20次查询，发现没有问题，都可以正常运行。</p>
<p>由于线上的环境风云变幻，所以还需要做很多操作。并发接口开发起来就像是在大海航行一样，平时风平浪静，但是一旦请求接踵而至的时候，就会波浪滔天，顷刻就有翻船的事故。所以我这次还是让测试准备进行压测一下，平时对这个接口感觉没有任何困难，但是现在看来，不光是代码的问题，比如redis的连接池、线程池的参数配置以及JVM的相关参数优化都是需要再三考虑的。</p>
<p>互联网公司就是这样，碰到的问题很多，想起了那句话，在互联网公司待一年相当于在其他公司待3年，不光是问题多，成长也很多，收获也很多。</p>
<p>等待下次上线，这次做好相关测试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.16号，是途牛的会员日，搭上前端组的紧急上线“快车”，准备发布一次，由于之前的车次缺失，导致有一些客户投诉反馈，正好这次修上去；还有一部分是价格问题，价格添加最后更新时间，如果超过规定时间就再次抓取价格，由于12306的价格也不是一成不变的，遇到特殊的情况还是需要手动处
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>车次缺失问题排查</title>
    <link href="http://dingran.tk/2017/05/16/%E8%BD%A6%E6%AC%A1%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://dingran.tk/2017/05/16/车次缺失问题排查/</id>
    <published>2017-05-16T02:54:04.000Z</published>
    <updated>2017-05-16T10:35:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.10上线一版之后，在5.19号听到客户有反馈有些车次没有和12306进行同步，我很好奇，是数据没有抓下来么？还是12306接口返回结果又有什么变化么？</p>
<p>我在本地以及测试环境上查询相关车次均能够正常显示，首先排除了12306返回的结果问题，应该是自己的代码哪里没有处理好，造成车次丢失，可是没有办法正确定位问题。</p>
<p>5.15号团建回来第一天上班，出现了好几单这个问题，有一个Z29的车次映入眼帘，由于只能使用ELK查看日志，不是很方便还有延迟，但是怀着试试的心态，我调用这个接口，赶快查看日志，输入关键字Z29调节时间到最近，搜索，哇塞，出现了，报了一个匹配车次的异常。ok，有异常出现，那么下面就是排查问题了，后面跟着nullpointer，可惜堆栈没有打出来，不过参数打印出来了，根据打印日志找到相关的代码，排查一下，最后定位到是反刷结果的时候出现的问题，在用户成功下单后，会把真的下单结果反刷给dtc，由于算下铺的时候需要用到硬座，但是Z29这种车是没有硬座的，于是出现空指针异常，判断没有判断到位，造成有相关车次的丢失。</p>
<p>于是修改代码，将线上的反刷缓存放到测试redis里面，在用我们自己的程序跑一下，果然报错了，并且丢失了那个车次，于是根据问题，修改代码，修复了这个问题。</p>
<p>最近再彻底重构DTC数据中心的代码，有的地方重构出现没有考虑完整的情况，造成此类问题的发生，希望以后引起注意，勿再发生。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.10上线一版之后，在5.19号听到客户有反馈有些车次没有和12306进行同步，我很好奇，是数据没有抓下来么？还是12306接口返回结果又有什么变化么？&lt;/p&gt;
&lt;p&gt;我在本地以及测试环境上查询相关车次均能够正常显示，首先排除了12306返回的结果问题，应该是自己的代码哪
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>线程池理解误区</title>
    <link href="http://dingran.tk/2017/05/12/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%90%86%E8%A7%A3%E8%AF%AF%E5%8C%BA/"/>
    <id>http://dingran.tk/2017/05/12/线程池理解误区/</id>
    <published>2017-05-12T10:26:22.000Z</published>
    <updated>2017-05-12T10:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>线程池平时使用的都是很多的，特别是在系统并发的情况下，合理运用线程池就显得特别重要。线程池的参数有以下几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ThreadPoolExecutor mExecutor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,<span class="comment">// 核心线程数  </span></div><div class="line">                        maximumPoolSize, <span class="comment">// 最大线程数  </span></div><div class="line">                        keepAliveTime, <span class="comment">// 闲置线程存活时间  </span></div><div class="line">                        TimeUnit.MILLISECONDS,<span class="comment">// 时间单位  </span></div><div class="line">                        <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(),<span class="comment">// 线程队列  </span></div><div class="line">                        Executors.defaultThreadFactory(),<span class="comment">// 线程工厂  </span></div><div class="line">                        <span class="keyword">new</span> AbortPolicy()<span class="comment">// 队列已满,而且当前线程数已经超过最大线程数时的异常处理策略  </span></div><div class="line">                );</div></pre></td></tr></table></figure>
<p>这几个参数都能滚瓜烂熟的记下来，但是也许自己没太注意，学习不到位，我的理解是，线程池启动先启动corePoolSize的线程，超过这个线程就在启动一个，直到maxnumpoolsize,然后后面的再添加线程<br>就直接放到队列里面，但是查看代码却不是这样，随后上网查看相关资料，才恍然大悟，配置线程池要根据这个实际应用情况来定，比如来个请求，我起一个线程，线程池配置24，初始化12个，队列1000，那么就是说当<br>来12个请求后的13个请求就会进入队列，并不会创建第13个线程，就会造成请求超时，没有使线程达到最佳的利用率，所以借此<b>谨记</b>这个问题。</p>
<p>下面为线程池的运行过程：</p>
<ul>
<li><p>如果线程池的状态是RUNNING，线程池的大小小于配置的核心线程数，说明还可以创建新线程，则启动新的线程执行这个任务。</p>
</li>
<li><p>如果线程池的状态是RUNNING ，线程池的大小小于配置的最大线程数，并且任务队列已经满了，说明现有线程已经不能支持当前的任务了，并且线程池还有继续扩充的空间，就可以创建一个新的线程来处理提交的任务。</p>
</li>
<li><p>如果线程池的状态是RUNNING，当前线程池的大小大于等于配置的核心线程数，说明根据配置当前的线程数已经够用，不用创建新线程，只需把任务加入任务队列即可。如果任务队列不满，则提交的任务在任务队列中等待处理；如果任务队列满了则需要考虑是否要扩展线程池的容量。</p>
</li>
<li><p>当线程池已经关闭或者上面的条件都不能满足时，则进行拒绝策略，拒绝策略在RejectedExecutionHandler接口中定义，可以有多种不同的实现。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线程池平时使用的都是很多的，特别是在系统并发的情况下，合理运用线程池就显得特别重要。线程池的参数有以下几个：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="线程池" scheme="http://dingran.tk/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>途牛5.8号上线回顾</title>
    <link href="http://dingran.tk/2017/05/10/%E9%80%94%E7%89%9B5-8%E5%8F%B7%E4%B8%8A%E7%BA%BF%E5%9B%9E%E9%A1%BE/"/>
    <id>http://dingran.tk/2017/05/10/途牛5-8号上线回顾/</id>
    <published>2017-05-10T09:14:33.000Z</published>
    <updated>2017-05-11T09:59:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>5.8号，周一，是个上线的日子。本次改动如下：</p>
<ol>
<li>拼装12306返回数据采用多线程处理，本机试验下可提速50%左右</li>
<li>拼装缓存数据返回给前端，采用多线程处理，本机试验下可提速50%</li>
<li>再返回结果后要赋值反刷结果到列表里面，多次循环车次信息表，改动点：在拼装缓存结果的时候直接在多线程里面直接赋值反刷结果。</li>
</ol>
<p>总结：就是讲以前单一的解析数据改为多线程处理，化整为零，能够快速的反馈结果。</p>
<p>但是遗憾的是上线不到20分钟，接口预警界面直接报警，接口调用超时严重，没办法直接回滚代码。在jvisualvm监控线上某台jvm的时候发现这台jvm的线程总数已经达到990+，马上要突破1000了，要知道一台机器的<br>线程数量是有限的，线程是十分宝贵的资源，随便乱用会造成系统访问慢等问题发生，直接打开代码搜索new Thread，发现很多地方用了这个代码，全部改为线程池启动，再次搜索new Thread，发现某个前员工在实现initializingBean<br>的afterPropertiesSet里面创建线程池，各项参数配置的挺好的，为什么就是不放到spring进行托管呢，spring不就是做这件事的么？！没办法，开始将所有这种实现的方式的代码全部改为spring托管线程池<br>问运维人员线上服务器的系统参数，根据参数为每个线程池配置好合理的线程数量，然后再启动tomcat，原来启动需要将近400个线程，现在启动后不到180个，节省了近一半的数量。</p>
<p>然后就是更改代码，代码里面用了闭锁，在countDown.await的时候，添加时间控制，如果规定时间没有返回数据，返回的结果无效。这样不会出现线程出现无限等待的情况。</p>
<p>在使用countDown.countDown()的时候的代码全部用try catch，不管在何时，就算是出现异常，也要保证countDown。</p>
<p>这几天最主要的问题就是价格不准，由于预算紧张，代理ip有限，所以必须保证“好刀用到刀刃上”,在抓取价格的时候，如果某一天的价格已经抓取过一次了，就不再进行抓取了，但是这样会有个问题，就是价格<br>如果是10天之前抓的，但是第九天发现12306涨价了，那么这个价格我就没有办法保证是正确的价格。所以本次修改在每个价格的json后面加入lastUpdateTime，只要保证保证lastUpdateTime和当前时间的<br>差距在可配置的时间内，就不再进行抓取，这样就保证了价格准确性。如果规定时间内12306如果改变价格，可以删除缓存，就可以再重新抓取，根据以往的经验，12306不会随意变更价格，就算变更价格<br>也会在首页上进行公示，可以给我们有充足的时间进行改动，保证价格的准确性能够让用户进行买到火车票。</p>
<p>本次加入“开关”，先进行以前的不使用多线程进行处理，然后全部上线成功后使用多线程处理数据，这样可以统一监控数据。</p>
<p>希望今天上线一次成功。</p>
<hr>
<p>上线一次成功，余位通用接口顺利访问，响应时间也很可观，抢票专用接口刚开始还是很稳定的，但是运行一段时间后，再次发生超时现象预估计为线程池溢出，在一处代码发现bug是自己写代码没注意到整个逻辑，造成抢票接口频繁出现异常，后续已经改正。整个抢票在高并发下问题还有很多，也是自己所有积累的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;5.8号，周一，是个上线的日子。本次改动如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拼装12306返回数据采用多线程处理，本机试验下可提速50%左右&lt;/li&gt;
&lt;li&gt;拼装缓存数据返回给前端，采用多线程处理，本机试验下可提速50%&lt;/li&gt;
&lt;li&gt;再返回结果后要赋值反刷结果到列表里
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>记途牛火车票数据中心余位接口优化记录</title>
    <link href="http://dingran.tk/2017/05/05/%E8%AE%B0%E9%80%94%E7%89%9B%E7%81%AB%E8%BD%A6%E7%A5%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E4%BD%99%E4%BD%8D%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95/"/>
    <id>http://dingran.tk/2017/05/05/记途牛火车票数据中心余位接口优化记录/</id>
    <published>2017-05-05T08:23:29.000Z</published>
    <updated>2017-05-05T10:38:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是5月5号了，距离12306的整改接口整整过去了小半个月，现在数据中心的接口所覆盖&gt;的查询数据已经可以达到之前所有的数据。回头一想，我现在做的工作是有多么的被动，12<br>306抖一抖，我们就要震两三天，没办法，谁让我们是爬取人家的数据呢。</p>
<p>按照新的12306接口提供的数据采用竖线分割的方法获取的数据与之前的对比在效率上是有&gt;很大的差别的，至少从我本机上来看的。本机是公司配的开发机器：双核 8g内存 tomcat给予2g内存 但是改完的接口在我本地没查询一次几乎都不可能在5s内返回结果，也许是我开了其他应用导致的，但是之前相同情况下返回的结果也能在5s以内返回啊，这是有很大的问<br>题的，数据中心余位查询是核心接口，性能太慢了也说不过去了，而且还有很多其他分销商<br>接进来，这么慢不是会让人家吐槽的么。发布到测试环境反应速度还可以2~4秒跑长趟，但<br>是本机还是很慢，所以，还是从我的机器山入手，来查询瓶颈在哪：</p>
<p>找了一个车次 上海-南京 这个一天的车次大概有260个左右 所以就拿这个测，如果这个查询速度快了，那么其他的就会更快了。</p>
<ol>
<li><p>首先判断是否是12306返回的结果时间太长，加上日志，用java自带的毫秒函数来判断发<br>现12306返回的结果（上海-南京）最慢的也在2秒以内，70kb左右，由于使用代理ip可能还会有点耗时，也不会太久，但是我用接口调用用chrome浏览器发起请求到返回总共一共用了<br>20多秒，多以和12306和代理ip返回结果没有多大关系。</p>
</li>
<li><p>是不是拼装12306返回数据很慢呢？同样，打上日志，调用一次接口发现260个车次解析成对象放到list里面，总共耗时15秒左右，嗯，这是一个优化的地方，如何优化呢？我想到<br>使用多线程解析数据，然后将数据放到一个容器中，最后将容器数据返回即可。想法有了，<br>开始做，先创建一个list，然后循环12306返回数据，每拿到一组数据，用线程池发起一个线程去处理，外面用闭锁await，当所有线程都解析完成后，闭锁释放，实现起来也很容易，我先拿抢票接口做实验，调用接口查看时间发现可以在3秒左右返回数据这是相当的快呀，然后将一些没用的字符串去掉，比如string a = “abc”，这种也会创建临时变量的全部拿掉，减少创建对象节省jvm内存；再次相同的办法处理余位接口，拿上海到南京来查询，发现返回数据的速度快了很多，但是到chrome的数据返回时间还是有20多秒，这是怎么回事？</p>
</li>
<li><p>再次判断抢票专用接口和通用余位查询接口为什么这么大差距呢？对比发现抢票接口的缓存数据就是要返回的数据，是我当初就这么设计的，而通用余位查询接口返回的数据格式还需要再次进行改造才能返回前端展示，于是专门看buildCache方法，这个方法每次查询都会调用，包括数据格式的变化，还有价格的反刷的问题，瞬间我就想到价格反刷有问题，查看逻辑，里面会有个向前推得判断方法，现在12306经常一天一个价这种办法已经不太实用了，但是没办法，不能随便改，先打到日志看看处理完花费时间，全部处理完数据总共花了18秒左右，总共胡斐21秒左右，处理这个就花费了近3/4，太奢侈了，这距离我们规定的5秒以内差距太远了，我给每个车次反刷打上日志查看，每个车次处理还算快大概平局60ms左右，但是260*60大概有16秒左右，到这里其实就是单个线程一个一个处理，非常耗时。</p>
</li>
<li><p>找到问题症结了，开始继续采用多线程+闭锁处理，这样其实是多个线程并行，260个车次，在线程池并行处理下不到3秒就处理完了，真爽，发布代码，启动后，调用接口上海-南京，不走缓存，返回时间在3~4秒之间 ，再来个数据上海到北京大概有46个左右车次，不到一秒返回，走缓存就更快了，嗯，终于感受到多线程的快感了。</p>
</li>
<li><p>由于以上都是在我本机测试，所以我要发布到测试环境，提交代码，进行构建后，调用接口，发现上海-南京返回时间在1.2秒左右 ，之前返回还在5秒左右，提高了将近3秒左右，在查上海-北京几乎都是几百毫秒，秒回，加上缓存的作用下，相信后面再线上部署后会更加有效果。</p>
</li>
</ol>
<p>本次优化使用多线程+闭锁，其实没有多大的新意，但是我一直遵守一句话就是：做什么事要有想法，没想法做什么？其实所谓的想法就是经验，经验多了想法当然就多了，在平时平庸的代码里面，加上一些并行操作会让系统跑的更加快。</p>
<p>其中也遇到了很多问题，比如多线程向list里面存放数据的时候就会报concurrentModificationException，是因为迭代的时候发现list的数据个数发生变化就会报这个异常，那么就要解决这个问题，解决办法是copyonwritearraylist和collections.synchronizedList，由于我这边主要是写数据，经过对比查询，synchronizeList比较适合我，copyOnWrite适合读多写少的情况，改完后再也没有报这个异常。                                                  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是5月5号了，距离12306的整改接口整整过去了小半个月，现在数据中心的接口所覆盖&amp;gt;的查询数据已经可以达到之前所有的数据。回头一想，我现在做的工作是有多么的被动，12&lt;br&gt;306抖一抖，我们就要震两三天，没办法，谁让我们是爬取人家的数据呢。&lt;/p&gt;
&lt;p&gt;按照新
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>途牛火车票12306数据中心0426变动记录</title>
    <link href="http://dingran.tk/2017/05/04/%E8%AE%B0%E9%80%94%E7%89%9B%E7%81%AB%E8%BD%A6%E7%A5%A8%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%830426%E5%8F%98%E5%8A%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://dingran.tk/2017/05/04/记途牛火车票数据中心0426变动记录/</id>
    <published>2017-05-04T08:00:47.000Z</published>
    <updated>2017-05-05T07:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>我们能达到今天的成就，是因为我们站在巨人的肩膀上</p>
</blockquote>
<p>之前博客都是转发或者摘抄别人的优秀文档，自己很少弄点东西上来，也许是自己没有善于积累的习惯，今天灵机一动，想写点什么！</p>
<p>话说2017年4月26日，是我进途牛的第八个月了，一切过得都还是顺利，虽然每天或多或少会有一些线上的bug之类的问题，但是都不紧急，每天轻车熟路，按部就班。4.27号刚到公司楼下。德良打电话说余位接口查不出数据了，走的全是缓存数据，根据我的想法，查不出数据一共有两个方面1.代理ip封掉了2.服务降级了，我进入公司先查看代理ip情况，一切正常，服务也没有降级。我调用余位接口，发现返回都是昨天的数据。瞬间一股凉意袭上心头，查看12306突然发现返回的数据全部变掉了，造成我们这边“不认识”这是数据格式，没办法紧急和德良黄甲商量后抓紧修改，本来是上线日，所有数据中心的上线计划全部推掉，我开始解析12306返回的数据，之前是有字段标识的，现在全部是“|”分割，幸好之前我保留了一份完整的数据，然后查询相同车次，获取12306返回结果，一个一个对比，正好一共35个字段，问题来了，原来返回40多个，现在只有35个，缺少这么多，有一些还是结果必须要用的比如起售时间，心中暗骂12306不地道，不过想想要是我也不会传送这个字段，略显尴尬，先叫产品停掉预售票，然后开始写代码，瞬时感觉时间过得好快啊，到了下午4点，根据开闭原则，我没有直接修改原来的方法，新创建方法，一遍吐槽老代码写的烂一别提醒自己别干这样的事—老代码先把对象放进map里面，在给对象赋值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">pubic void main()&#123;</div><div class="line">Object obj = new Object();</div><div class="line">Map map = new HashMap()'</div><div class="line">map.put("obj",obj);</div><div class="line">obj.set...</div><div class="line">obj.set...</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>艾玛，这不是打破我的认知么，咱不能先创建好对象，赋值之后，在放进map里面，我还以为下面都是没用的数据，这引用传递都玩上天了。</p>
<p>下午4点一刻，第一个版本可以了，自测可以查出数据，兼容老的设计，一切都很妥当，但是就是没有车站开始预售时间啊，没办法，先把数据查出来，毕竟分销商（JD）和boss3打包已经爆炸了，赶快提交测试，经过几轮的bug修复，第一个版本上线了，可以查询12306最新的余位信息，还有一些细节没处理好，等这个版本上完已经晚上了，心好累，早些回去，第二天再收尾。如果按照之前的接口完成的任务量，现在的只完成了之前的60%左右的任务。</p>
<p>第二天4.28号，做了一宿改代码的噩梦后，boss3说我们这边传送的列车经过几天不对，我一查发现和他们的计算方式不对，原来这个字段是12306自己提供的，现在没有了，只能我自己搞了，修修改改可以了，由于之前资源落地的数据有很多是脏数据，导致这些数据要被更新掉，现在ris搜索的接口推送mq更新res，测试发现数据没有更新，我擦，一个接一个的问题啊，查看逻辑没有问题，问题出现在最后的mq的推送的问题，就是推送不过去啊，经过查看插入资源的代码，发现和更新的代码最后殊途同归啊，我擦，插入资源用tsp，更新资源用mq，这是什么道理，我直接将更新资源改用插入的tsp，我了擦，居然直接更新数据，困扰好长时间的问题解决了（这里省略我查找对比插入和更新资源的过程），随后在测试机器进行测试，出发时间，到达时间，售价，随便改，查询后立即更新。就是这么高效，喜欢这种感觉。今天再紧急上线，达到之前接口80%的功能量。</p>
<p>好好休息了一个周末，5.2号来，还差预售时间了，刚开始准备放进db里面，后来考虑还要创建表、查询频率和速率等方面，如果预售时间发生变化，修改起来比较困难，想来先去，还是放入缓存吧，但是缓存需要支持key-value类型，查看项目用的redis太老了，不敢升级，升级报错一堆，没把那只能继续封装原来接口，采用redis的hash的方法，封装了两个接口，数据存进去，起售时间-车站s，ok，完美解决。再封装一个方法，根据车站查询预售时间，就是根据value查找key，恶心的上海的各个站还是预售时间不一致，我擦，没办法，先模糊识别，在精确识别，一套查询袭来耗时也就10毫秒左右，可以忍受。后面比较麻烦的来了，就是算预售时间，通用接口的把预售时间赋值上去，稍微改动没有问题，但是抢票接口的就麻烦了，逻辑不一致，经过多次修改，终于搞定了，很完美。经过这一天的完成，接口终于可以达到之前99%的功能了。</p>
<p>由于12306接口的返回结果变动，改用“|”分割的数据解析，在我本地机器上运行起来很慢，但是在测试服务器上和线上还是很快的，经过打日志发现解析12306返回结果数据相当耗时，所以今天我想采用多线程+闭锁的方式来实现，说干就干，抽取代码，改用线程池+闭锁，实现起来不难，测试抢票接口之前本机上5s都不能返回数据，现在2~4秒以内就可以返回，算是不小的改进，化整为零的思想还是不错的。但是又出现了list的java.util.concurrentModificationException，这个需要细心排查，没有进行remove操作还是会出现，排查中..（让我想起面试EMC的面试官的一道题，就是统计一本书的每个字出现的个数，什么方法都行，当时稚嫩的我如何想到分布式或者多线程呀，想想就汗颜呀）</p>
<p>回想起来，我这一短时间到底在途牛学到了什么，仔细回想其实还是不少的，我新开了一个接口供自己负责的牛抢票用，第一次一段时间后报警了，经过简单排查插入数据库可能频繁访问拖得db很慢，造成查询很慢，去掉后，自上线发现还是很慢，这次准备改为闭锁，之前是用的future.get时间返回，但是很慢，正在改进中。一个接口在正常情况下没问题，但是在高并发下就会凸显一系列问题。</p>
<p>崎岖的路，继续走。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们能达到今天的成就，是因为我们站在巨人的肩膀上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前博客都是转发或者摘抄别人的优秀文档，自己很少弄点东西上来，也许是自己没有善于积累的习惯，今天灵机一动，想写点什么！&lt;/p&gt;
&lt;p&gt;话说2017年4月26
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>spring的bean生命周期</title>
    <link href="http://dingran.tk/2017/04/24/spring%E7%9A%84bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://dingran.tk/2017/04/24/spring的bean生命周期/</id>
    <published>2017-04-24T03:18:37.000Z</published>
    <updated>2017-04-24T03:35:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-bean-的生命周期"><a href="#spring-bean-的生命周期" class="headerlink" title="spring bean 的生命周期"></a>spring bean 的生命周期</h1><p>Spring作为当前Java最流行、最强大的轻量级框架，受到了程序员的热烈欢迎。准确的了解Spring Bean的生命周期是非常必要的。我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p>
<p> 转载请注明地址 <b><a href="http://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="external">http://www.cnblogs.com/zrtqsk/p/3735273.html</a></b>，谢谢。</p>
<h2 id="一、生命周期流程图："><a href="#一、生命周期流程图：" class="headerlink" title="一、生命周期流程图："></a>一、生命周期流程图：</h2><p>Spring Bean的完整生命周期从创建Spring容器开始，直到最终Spring容器销毁Bean，这其中包含了一系列关键点。<br><img src="http://images.cnitblog.com/i/580631/201405/181453414212066.png" alt=""></p>
<p>若容器注册了以上各种接口，程序那么将会按照以上的流程进行。下面将仔细讲解各接口作用。</p>
<h2 id="二、各种接口方法分类"><a href="#二、各种接口方法分类" class="headerlink" title="二、各种接口方法分类"></a>二、各种接口方法分类</h2><p>Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<h3 id="1、Bean自身的方法："><a href="#1、Bean自身的方法：" class="headerlink" title="1、Bean自身的方法："></a>1、Bean自身的方法：</h3><p>这个包括了Bean本身调用的方法和通过配置文件中<bean>的init-method和destroy-method指定的方法</bean></p>
<h3 id="2、Bean级生命周期接口方法："><a href="#2、Bean级生命周期接口方法：" class="headerlink" title="2、Bean级生命周期接口方法："></a>2、Bean级生命周期接口方法：</h3><p>这个包括了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这些接口的方法</p>
<h3 id="3、容器级生命周期接口方法："><a href="#3、容器级生命周期接口方法：" class="headerlink" title="3、容器级生命周期接口方法："></a>3、容器级生命周期接口方法：</h3><p>这个包括了InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p>
<h3 id="4、工厂后处理器接口方法："><a href="#4、工厂后处理器接口方法：" class="headerlink" title="4、工厂后处理器接口方法：　　"></a>4、工厂后处理器接口方法：　　</h3><p>这个包括了AspectJWeavingEnabler,ConfigurationClassPostProcessor,CustomAutowireConfigurer等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p>
<h2 id="三、演示"><a href="#三、演示" class="headerlink" title="三、演示"></a>三、演示</h2><p>我们用一个简单的Spring Bean来演示一下Spring Bean的生命周期。</p>
<h3 id="1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法"><a href="#1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法" class="headerlink" title="1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法"></a>1、首先是一个简单的SpringBean，调用Bean自身的方法和Bean级生命周期接口方法</h3><p>为了方便演示，它实现了BeanNameAware、BeanFactoryAware、InitializingBean和DiposableBean这4个接口，同时有2个方法，对应配置文件中<bean>的init-method和destroy-method。如下：</bean></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> qsk</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">BeanNameAware</span>,</span></div><div class="line">        <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String address;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> phone;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</div><div class="line">    <span class="keyword">private</span> String beanName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【构造器】调用Person的构造器实例化"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【注入属性】注入属性name"</span>);</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【注入属性】注入属性address"</span>);</div><div class="line">        <span class="keyword">this</span>.address = address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> phone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(<span class="keyword">int</span> phone)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【注入属性】注入属性phone"</span>);</div><div class="line">        <span class="keyword">this</span>.phone = phone;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Person [address="</span> + address + <span class="string">", name="</span> + name + <span class="string">", phone="</span></div><div class="line">                + phone + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是BeanFactoryAware接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory arg0)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()"</span>);</div><div class="line">        <span class="keyword">this</span>.beanFactory = arg0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是BeanNameAware接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String arg0)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【BeanNameAware接口】调用BeanNameAware.setBeanName()"</span>);</div><div class="line">        <span class="keyword">this</span>.beanName = arg0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是InitializingBean接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"【InitializingBean接口】调用InitializingBean.afterPropertiesSet()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这是DiposibleBean接口方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【DiposibleBean接口】调用DiposibleBean.destory()"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 通过&lt;bean&gt;的destroy-method属性指定的初始化方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestory</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、接下来是演示BeanPostProcessor接口的方法，如下："><a href="#2、接下来是演示BeanPostProcessor接口的方法，如下：" class="headerlink" title="2、接下来是演示BeanPostProcessor接口的方法，如下："></a>2、接下来是演示BeanPostProcessor接口的方法，如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out.println(<span class="string">"这是BeanPostProcessor实现类构造器！！"</span>);</div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object arg0, String arg1)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">        .println(<span class="string">"BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！"</span>);</div><div class="line">        <span class="keyword">return</span> arg0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object arg0, String arg1)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">        .println(<span class="string">"BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！"</span>);</div><div class="line">        <span class="keyword">return</span> arg0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，BeanPostProcessor接口包括2个方法postProcessAfterInitialization和postProcessBeforeInitialization，这两个方法的第一个参数都是要处理的Bean对象，第二个参数都是Bean的name。返回值也都是要处理的Bean对象。这里要注意。</p>
<h3 id="3、InstantiationAwareBeanPostProcessor-接口本质是BeanPostProcessor的子接口"><a href="#3、InstantiationAwareBeanPostProcessor-接口本质是BeanPostProcessor的子接口" class="headerlink" title="3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口"></a>3、InstantiationAwareBeanPostProcessor 接口本质是BeanPostProcessor的子接口</h3><p>，一般我们继承Spring为其提供的适配器类InstantiationAwareBeanPostProcessor Adapter来使用它，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.beans.PropertyDescriptor;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessorAdapter;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span></span></div><div class="line">        <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> &#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接口方法、实例化Bean之前调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class beanClass,</span></span></div><div class="line">            String beanName) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接口方法、实例化Bean之后调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法"</span>);</div><div class="line">        <span class="keyword">return</span> bean;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 接口方法、设置某个属性时调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs,</span></span></div><div class="line">            PropertyDescriptor[] pds, Object bean, String beanName)</div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法"</span>);</div><div class="line">        <span class="keyword">return</span> pvs;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个有3个方法，其中第二个方法postProcessAfterInitialization就是重写了BeanPostProcessor的方法。第三个方法postProcessPropertyValues用来操作属性，返回值也应该是PropertyValues对象。</p>
<h3 id="4、演示工厂后处理器接口方法，如下："><a href="#4、演示工厂后处理器接口方法，如下：" class="headerlink" title="4、演示工厂后处理器接口方法，如下："></a>4、演示工厂后处理器接口方法，如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanDefinition;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBeanFactoryPostProcessor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        System.out.println(<span class="string">"这是BeanFactoryPostProcessor实现类构造器！！"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory arg0)</span></span></div><div class="line">            <span class="keyword">throws</span> BeansException &#123;</div><div class="line">        System.out</div><div class="line">                .println(<span class="string">"BeanFactoryPostProcessor调用postProcessBeanFactory方法"</span>);</div><div class="line">        BeanDefinition bd = arg0.getBeanDefinition(<span class="string">"person"</span>);</div><div class="line">        bd.getPropertyValues().addPropertyValue(<span class="string">"phone"</span>, <span class="string">"110"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5、配置文件如下beans-xml，很简单，使用ApplicationContext-处理器不用手动注册："><a href="#5、配置文件如下beans-xml，很简单，使用ApplicationContext-处理器不用手动注册：" class="headerlink" title="5、配置文件如下beans.xml，很简单，使用ApplicationContext,处理器不用手动注册："></a>5、配置文件如下beans.xml，很简单，使用ApplicationContext,处理器不用手动注册：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">            http://www.springframework.org/schema/beans </div><div class="line">            http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instantiationAwareBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyInstantiationAwareBeanPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanFactoryPostProcessor"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.MyBeanFactoryPostProcessor"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"springBeanTest.Person"</span> <span class="attr">init-method</span>=<span class="string">"myInit"</span></span></div><div class="line">        <span class="attr">destroy-method</span>=<span class="string">"myDestory"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">p:name</span>=<span class="string">"张三"</span> <span class="attr">p:address</span>=<span class="string">"广州"</span></div><div class="line">        <span class="attr">p:phone</span>=<span class="string">"15900000000"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="6、下面测试一下："><a href="#6、下面测试一下：" class="headerlink" title="6、下面测试一下："></a>6、下面测试一下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springBeanTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanLifeCycle</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"现在开始初始化容器"</span>);</div><div class="line">        </div><div class="line">        ApplicationContext factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"springBeanTest/beans.xml"</span>);</div><div class="line">        System.out.println(<span class="string">"容器初始化成功"</span>);    </div><div class="line">        <span class="comment">//得到Preson，并使用</span></div><div class="line">        Person person = factory.getBean(<span class="string">"person"</span>,Person.class);</div><div class="line">        System.out.println(person);</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"现在开始关闭容器！"</span>);</div><div class="line">        ((ClassPathXmlApplicationContext)factory).registerShutdownHook();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="关闭容器使用的是实际是AbstractApplicationContext的钩子方法。"><a href="#关闭容器使用的是实际是AbstractApplicationContext的钩子方法。" class="headerlink" title="关闭容器使用的是实际是AbstractApplicationContext的钩子方法。"></a>关闭容器使用的是实际是AbstractApplicationContext的钩子方法。</h3><p>我们来看一下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">现在开始初始化容器</div><div class="line">2014-5-18 15:46:20 org.springframework.context.support.AbstractApplicationContext prepareRefresh</div><div class="line">信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@19a0c7c: startup date [Sun May 18 15:46:20 CST 2014]; root of context hierarchy</div><div class="line">2014-5-18 15:46:20 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions</div><div class="line">信息: Loading XML bean definitions from class path resource [springBeanTest/beans.xml]</div><div class="line">这是BeanFactoryPostProcessor实现类构造器！！</div><div class="line">BeanFactoryPostProcessor调用postProcessBeanFactory方法</div><div class="line">这是BeanPostProcessor实现类构造器！！</div><div class="line">这是InstantiationAwareBeanPostProcessorAdapter实现类构造器！！</div><div class="line">2014-5-18 15:46:20 org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons</div><div class="line">信息: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9934d4: defining beans [beanPostProcessor,instantiationAwareBeanPostProcessor,beanFactoryPostProcessor,person]; root of factory hierarchy</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessBeforeInstantiation方法</div><div class="line">【构造器】调用Person的构造器实例化</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessPropertyValues方法</div><div class="line">【注入属性】注入属性address</div><div class="line">【注入属性】注入属性name</div><div class="line">【注入属性】注入属性phone</div><div class="line">【BeanNameAware接口】调用BeanNameAware.setBeanName()</div><div class="line">【BeanFactoryAware接口】调用BeanFactoryAware.setBeanFactory()</div><div class="line">BeanPostProcessor接口方法postProcessBeforeInitialization对属性进行更改！</div><div class="line">【InitializingBean接口】调用InitializingBean.afterPropertiesSet()</div><div class="line">【init-method】调用&lt;bean&gt;的init-method属性指定的初始化方法</div><div class="line">BeanPostProcessor接口方法postProcessAfterInitialization对属性进行更改！</div><div class="line">InstantiationAwareBeanPostProcessor调用postProcessAfterInitialization方法</div><div class="line">容器初始化成功</div><div class="line">Person [address=广州, name=张三, phone=110]</div><div class="line">现在开始关闭容器！</div><div class="line">【DiposibleBean接口】调用DiposibleBean.destory()</div><div class="line">【destroy-method】调用&lt;bean&gt;的destroy-method属性指定的初始化方法</div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>————————如果觉得本博文还行，别忘了推荐一下哦，谢谢！</li>
<li>作者：钱书康</li>
<li>欢迎转载，请保留此段声明。</li>
<li>出处：<a href="http://www.cnblogs.com/zrtqsk/" target="_blank" rel="external">http://www.cnblogs.com/zrtqsk/</a><br>*/</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-bean-的生命周期&quot;&gt;&lt;a href=&quot;#spring-bean-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;spring bean 的生命周期&quot;&gt;&lt;/a&gt;spring bean 的生命周期&lt;/h1&gt;&lt;p&gt;Spring作为当前
    
    </summary>
    
      <category term="spring" scheme="http://dingran.tk/categories/spring/"/>
    
    
      <category term="spring" scheme="http://dingran.tk/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的if使用</title>
    <link href="http://dingran.tk/2017/04/19/mysql%E4%B8%AD%E7%9A%84if%E4%BD%BF%E7%94%A8/"/>
    <id>http://dingran.tk/2017/04/19/mysql中的if使用/</id>
    <published>2017-04-19T06:05:22.000Z</published>
    <updated>2017-04-19T06:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>mysql中的if用法：</p>
<ul>
<li>一种是我们经常使用的case when</li>
<li>还有一种是mysql本身自带函数 if(exp1,exp2,exp3)</li>
</ul>
<p>用法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">select</span> <span class="keyword">if</span>(<span class="keyword">max</span>(<span class="keyword">id</span>) <span class="keyword">is</span> <span class="literal">null</span>,<span class="number">1</span>,<span class="keyword">max</span>(<span class="keyword">id</span>)+<span class="number">1</span>) <span class="keyword">from</span> <span class="keyword">table</span></div><div class="line">#描述为如果<span class="keyword">id</span>最大值是<span class="literal">null</span>，就为<span class="number">1</span>，如果最大<span class="keyword">id</span>不为<span class="literal">null</span>，就将最大<span class="keyword">id</span>加<span class="number">1</span></div></pre></td></tr></table></figure>
<p>可以用来进行一些简单的转换<br>mybatis推荐使用typehandler</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql中的if用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是我们经常使用的case when&lt;/li&gt;
&lt;li&gt;还有一种是mysql本身自带函数 if(exp1,exp2,exp3)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlig
    
    </summary>
    
      <category term="数据库" scheme="http://dingran.tk/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://dingran.tk/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>伪共享，并发编程无声的性能杀手</title>
    <link href="http://dingran.tk/2017/04/19/%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%97%A0%E5%A3%B0%E7%9A%84%E6%80%A7%E8%83%BD%E6%9D%80%E6%89%8B/"/>
    <id>http://dingran.tk/2017/04/19/伪共享，并发编程无声的性能杀手/</id>
    <published>2017-04-19T03:43:03.000Z</published>
    <updated>2017-04-19T03:52:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>伪共享，并发编程无声的性能杀手</p>
</blockquote>
<p>原文链接：<a href="http://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="external">伪共享，并发编程无声的性能杀手</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;伪共享，并发编程无声的性能杀手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.cnblogs.com/cyfonly/p/5800758.html&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
      <category term="并发" scheme="http://dingran.tk/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://dingran.tk/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="http://dingran.tk/2017/04/17/%E6%A0%91/"/>
    <id>http://dingran.tk/2017/04/17/树/</id>
    <published>2017-04-17T08:02:07.000Z</published>
    <updated>2017-04-17T10:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树是每个结点最多有两个子树的有序树。通常子树的根被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用作二叉查找树和二叉堆。二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2的（i-1）次方个结点；深度为k的二叉树至多有2的k次 − 1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1。</p>
<h2 id="两个重要的概念："><a href="#两个重要的概念：" class="headerlink" title="两个重要的概念："></a>两个重要的概念：</h2><p>(1)完全二叉树——只有最下面的两层结点度小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树；</p>
<p>(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶结点都处在最底层的二叉树,。</p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p>(1) 在二叉树中，第i层的结点总数不超过2^(i-1)；</p>
<p>(2) 深度为h的二叉树最多有2^h-1个结点(h&gt;=1)，最少有h个结点；</p>
<p>(3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，</p>
<p>则N0=N2+1；</p>
<p>(4) 具有n个结点的完全二叉树的深度为int（log2n）+1</p>
<p>(5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：</p>
<p>若I为结点编号则 如果I&lt;&gt;1，则其父结点的编号为I/2；</p>
<p>如果2<em>I&lt;=N，则其左儿子（即左子树的根结点）的编号为2</em>I；若2*I&gt;N，则无左儿子；</p>
<p>如果2<em>I+1&lt;=N，则其右儿子的结点编号为2</em>I+1；若2*I+1&gt;N，则无右儿子。</p>
<p>(6)给定N个节点，能构成h(N)种不同的二叉树。</p>
<p>h(N)为卡特兰数的第N项。h(n)=C(n,2*n)/(n+1)。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>前序遍历：根节点-&gt;左子树-&gt;右子树<br>中序遍历：左子树-&gt;根节点-&gt;右子树<br>后序遍历：左子树-&gt;右子树-&gt;根节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> tree;  </div><div class="line">  </div><div class="line"><span class="keyword">import</span> java.util.LinkedList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line">  </div><div class="line"><span class="comment">/** </span></div><div class="line"> * 功能：把一个数组的值存入二叉树中，然后进行3种方式的遍历 </div><div class="line"> *  </div><div class="line"> * 参考资料0:数据结构(C语言版)严蔚敏 </div><div class="line"> *  </div><div class="line"> * 参考资料1：http://zhidao.baidu.com/question/81938912.html </div><div class="line"> *  </div><div class="line"> * 参考资料2：http://cslibrary.stanford.edu/110/BinaryTrees.html#java </div><div class="line"> *  </div><div class="line"> * <span class="doctag">@author</span> ocaicai@yeah.net <span class="doctag">@date</span>: 2011-5-17 </div><div class="line"> *  </div><div class="line"> */  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinTreeTraverse2</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; nodeList = <span class="keyword">null</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 内部类：节点 </div><div class="line">     *  </div><div class="line">     * <span class="doctag">@author</span> ocaicai@yeah.net <span class="doctag">@date</span>: 2011-5-17 </div><div class="line">     *  </div><div class="line">     */  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  </div><div class="line">        Node leftChild;  </div><div class="line">        Node rightChild;  </div><div class="line">        <span class="keyword">int</span> data;  </div><div class="line">  </div><div class="line">        Node(<span class="keyword">int</span> newData) &#123;  </div><div class="line">            leftChild = <span class="keyword">null</span>;  </div><div class="line">            rightChild = <span class="keyword">null</span>;  </div><div class="line">            data = newData;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBinTree</span><span class="params">()</span> </span>&#123;  </div><div class="line">        nodeList = <span class="keyword">new</span> LinkedList&lt;Node&gt;();  </div><div class="line">        <span class="comment">// 将一个数组的值依次转换为Node节点  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nodeIndex = <span class="number">0</span>; nodeIndex &lt; array.length; nodeIndex++) &#123;  </div><div class="line">            nodeList.add(<span class="keyword">new</span> Node(array[nodeIndex]));  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 对前lastParentIndex-1个父节点按照父节点与孩子节点的数字关系建立二叉树  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> parentIndex = <span class="number">0</span>; parentIndex &lt; array.length / <span class="number">2</span> - <span class="number">1</span>; parentIndex++) &#123;  </div><div class="line">            <span class="comment">// 左孩子  </span></div><div class="line">            nodeList.get(parentIndex).leftChild = nodeList  </div><div class="line">                    .get(parentIndex * <span class="number">2</span> + <span class="number">1</span>);  </div><div class="line">            <span class="comment">// 右孩子  </span></div><div class="line">            nodeList.get(parentIndex).rightChild = nodeList  </div><div class="line">                    .get(parentIndex * <span class="number">2</span> + <span class="number">2</span>);  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">// 最后一个父节点:因为最后一个父节点可能没有右孩子，所以单独拿出来处理  </span></div><div class="line">        <span class="keyword">int</span> lastParentIndex = array.length / <span class="number">2</span> - <span class="number">1</span>;  </div><div class="line">        <span class="comment">// 左孩子  </span></div><div class="line">        nodeList.get(lastParentIndex).leftChild = nodeList  </div><div class="line">                .get(lastParentIndex * <span class="number">2</span> + <span class="number">1</span>);  </div><div class="line">        <span class="comment">// 右孩子,如果数组的长度为奇数才建立右孩子  </span></div><div class="line">        <span class="keyword">if</span> (array.length % <span class="number">2</span> == <span class="number">1</span>) &#123;  </div><div class="line">            nodeList.get(lastParentIndex).rightChild = nodeList  </div><div class="line">                    .get(lastParentIndex * <span class="number">2</span> + <span class="number">2</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 先序遍历 </div><div class="line">     *  </div><div class="line">     * 这三种不同的遍历结构都是一样的，只是先后顺序不一样而已 </div><div class="line">     *  </div><div class="line">     * <span class="doctag">@param</span> node </div><div class="line">     *            遍历的节点 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        System.out.print(node.data + <span class="string">" "</span>);  </div><div class="line">        preOrderTraverse(node.leftChild);  </div><div class="line">        preOrderTraverse(node.rightChild);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 中序遍历 </div><div class="line">     *  </div><div class="line">     * 这三种不同的遍历结构都是一样的，只是先后顺序不一样而已 </div><div class="line">     *  </div><div class="line">     * <span class="doctag">@param</span> node </div><div class="line">     *            遍历的节点 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        inOrderTraverse(node.leftChild);  </div><div class="line">        System.out.print(node.data + <span class="string">" "</span>);  </div><div class="line">        inOrderTraverse(node.rightChild);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 后序遍历 </div><div class="line">     *  </div><div class="line">     * 这三种不同的遍历结构都是一样的，只是先后顺序不一样而已 </div><div class="line">     *  </div><div class="line">     * <span class="doctag">@param</span> node </div><div class="line">     *            遍历的节点 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(Node node)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        postOrderTraverse(node.leftChild);  </div><div class="line">        postOrderTraverse(node.rightChild);  </div><div class="line">        System.out.print(node.data + <span class="string">" "</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        BinTreeTraverse2 binTree = <span class="keyword">new</span> BinTreeTraverse2();  </div><div class="line">        binTree.createBinTree();  </div><div class="line">        <span class="comment">// nodeList中第0个索引处的值即为根节点  </span></div><div class="line">        Node root = nodeList.get(<span class="number">0</span>);  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"先序遍历："</span>);  </div><div class="line">        preOrderTraverse(root);  </div><div class="line">        System.out.println();  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"中序遍历："</span>);  </div><div class="line">        inOrderTraverse(root);  </div><div class="line">        System.out.println();  </div><div class="line">  </div><div class="line">        System.out.println(<span class="string">"后序遍历："</span>);  </div><div class="line">        postOrderTraverse(root);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>result:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">先序遍历：  </div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">9</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>   </div><div class="line">中序遍历：  </div><div class="line"><span class="number">8</span> <span class="number">4</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">6</span> <span class="number">3</span> <span class="number">7</span>   </div><div class="line">后序遍历：  </div><div class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">6</span> <span class="number">7</span> <span class="number">3</span> <span class="number">1</span></div></pre></td></tr></table></figure>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p>平衡二叉树，又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差之差的绝对值不超过1.。</p>
<p>常用算法有：红黑树、AVL树、Treap等。</p>
<h2 id="平衡二叉树的调整方法"><a href="#平衡二叉树的调整方法" class="headerlink" title="平衡二叉树的调整方法"></a>平衡二叉树的调整方法</h2><p>平衡二叉树是在构造二叉排序树的过程中，每当插入一个新结点时，首先检查是否因插入新结点而破坏了二叉排序树的平衡性，若是，则找出其中的最小不平衡子树，在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。具体步骤如下：</p>
<p>⑴ 每当插入一个新结点，从该结点开始向上计算各结点的平衡因子，即计算该结点的祖先结点的平衡因子，若该结点的祖先结点的平衡因子的绝对值均不超过1，则平衡二叉树没有失去平衡，继续插入结点；</p>
<p>⑵ 若插入结点的某祖先结点的平衡因子的绝对值大于1，则找出其中最小不平衡子树的根结点；</p>
<p>⑶ 判断新插入的结点与最小不平衡子树的根结点的关系，确定是哪种类型的调整；</p>
<p>⑷ 如果是LL型或RR型，只需应用扁担原理旋转一次，在旋转过程中，如果出现冲突，应用旋转优先原则调整冲突；如果是LR型或LR型，则需应用扁担原理旋转两次，第一次最小不平衡子树的根结点先不动，调整插入结点所在子树，第二次再调整最小不平衡子树，在旋转过程中，如果出现冲突，应用旋转优先原则调整冲突；</p>
<p>⑸ 计算调整后的平衡二叉树中各结点的平衡因子，检验是否因为旋转而破坏其他结点的平衡因子，以及调整后的平衡二叉树中是否存在平衡因子大于1的结点。</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/hytdsky/609806/o_2008111712242127.jpg" alt=""></p>
<p>（b）左边的图 左子数的高度为3，右子树的高度为1，相差超过1</p>
<p>（b）右边的图 -2的左子树高度为0  右子树的高度为2，相差超过1</p>
<h1 id="完全二叉树-Complete-Binary-Tree"><a href="#完全二叉树-Complete-Binary-Tree" class="headerlink" title="完全二叉树(Complete Binary Tree)"></a>完全二叉树(Complete Binary Tree)</h1><p>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点，这就是完全二叉树。</p>
<h2 id="完全二叉树特点"><a href="#完全二叉树特点" class="headerlink" title="完全二叉树特点"></a>完全二叉树特点</h2><p>一、叶子结点只可能在最大的两层上出现,对任意结点，若其右分支下的子孙最大层次为L，则其左分支下的子孙的最大层次必为L 或 L+1；</p>
<p>二、出于简便起见,完全二叉树通常采用数组而不是链表存储,其存储结构如下:</p>
<p>var tree:array[1..n]of longint;{n:integer;n&gt;=1}</p>
<p>对于tree[i]，有如下特点：</p>
<p>（1）若i为奇数且i&gt;1，那么tree[i]的左兄弟为tree[i-1]；</p>
<p>（2）若i为偶数且i&lt;n，那么tree[i]的右兄弟为tree[i+1]；</p>
<p>（3）若i&gt;1，tree[i]的双亲为tree[i div 2]；</p>
<p>（4）若2<em>i&lt;=n，那么tree[i]的左孩子为tree[2</em>i]；若2<em>i+1&lt;=n，那么tree[i]的右孩子为tree[2</em>i+1]；</p>
<p>（5）若i&gt;n div 2,那么tree[i]为叶子结点（对应于（3））；</p>
<p>（6）若i&lt;(n-1) div 2.那么tree[i]必有两个孩子（对应于（4））。</p>
<p>特别地：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</p>
<h2 id="完全二叉树叶子节点的算法"><a href="#完全二叉树叶子节点的算法" class="headerlink" title="完全二叉树叶子节点的算法"></a>完全二叉树叶子节点的算法</h2><p>如果一棵具有n个结点的深度为k的二叉树，它的每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应，这棵二叉树称为完全二叉树。</p>
<p>可以根据公式进行推导，假设n0是度为0的结点总数（即叶子结点数），n1是度为1的结点总数，n2是度为2的结点总数，由二叉树的性质可知：n0＝n2＋1，则n= n0＋n1＋n2（其中n为完全二叉树的结点总数），由上述公式把n2消去得：n= 2n0+n1－1，由于完全二叉树中度为1的结点数只有两种可能0或1，由此得到n0＝（n＋1）/2或n0＝n/2，合并成一个公式：n0＝（n＋1）/2 ，就可根据完全二叉树的结点总数计算出叶子结点数。</p>
<h1 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h1><p>一棵深度为k，且有2的(k)次方－1个节点的二叉树 特点：每一层上的结点数都是最大结点数</p>
<h2 id="完全二叉树的定义："><a href="#完全二叉树的定义：" class="headerlink" title="完全二叉树的定义："></a>完全二叉树的定义：</h2><p>深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。 特点：叶子结点只可能在层次最大的两层上出现；对任一结点，若其右分支下子孙的最大层次为l，则其左分支下子孙的最大层次必为l 或l+1 满二叉树：一棵深度为k，且有2的(k)次方－1个节点的二叉树 特点：每一层上的结点数都是最大结点数 满二叉树肯定是完全二叉树完全二叉树不一定是满二叉树</p>
<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>哈夫曼树又称最优二叉树，是一类带权路径长度最短的树</p>
<h2 id="最优二叉树的构造算法步骤："><a href="#最优二叉树的构造算法步骤：" class="headerlink" title="最优二叉树的构造算法步骤："></a>最优二叉树的构造算法步骤：</h2><p>(1)根据给定的n个权值w1,w2,…,wn构成n棵二叉树森林F={T1,T2,…,Tn}，其中每一棵二叉树Ti中都只有一个权为wi的根结点，其左、右子树为空。</p>
<p>(2)在森林F中选出两棵根结点权值最小的树作为一棵新二叉树的左、右子树，新二叉树的根结点的权值为其左、右子树根结点的权值之和。</p>
<p>(3)从F中删除这两棵二叉树，同时把新二叉树加入到F中。</p>
<p>(4)重复步骤(2)、(3),直到F中只含有一棵树为止，此树便为最优二叉树。</p>
<p>哈夫曼树的构造过程示意图如下：</p>
<p><img src="http://img.blog.csdn.net/20160408000126221?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>哈夫曼编码是一种变长编码。其定义如下：<br>对于给定的字符集D={d1,d2,…,dn}及其频率分布F={w1,w2,…,wn}，用d1,d2,…,dn作为叶结点，w1,w2,…,wn作为结点的权，利用哈夫曼算法构造一棵最优二叉树，将树中每个分支结点的左分支标上”0”；右分支标上”1”，把从根到每个叶子的路径符号(“0”或”1”)连接起来，作为该叶子的编码。<br>哈夫曼编码是在哈夫曼树的基础上求出来的，其基本思想是：从叶子结点di(0&lt;=i&lt;n)出发，向上回溯至根结点，依次求出每个字符的编码。<br>示例：对于字符集D={A，B，C，D}，其频率(单位：千次)分布为F={12，6，2，18}，下图给出D的哈夫曼编码图</p>
<p><img src="http://img.blog.csdn.net/20160408235453592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="哈夫曼编码的回溯步骤如下："><a href="#哈夫曼编码的回溯步骤如下：" class="headerlink" title="哈夫曼编码的回溯步骤如下："></a>哈夫曼编码的回溯步骤如下：</h2><p>(1)选出哈夫曼树的某一个叶子结点。</p>
<p>(2)利用其双亲指针parent找到其双亲结点。</p>
<p>(3)利用找到的双亲结点的指针域中的lchild和rchild，判断该结点是双亲的左孩子还是右孩子。若该结点是其双亲结点的左孩子，则生成代码0；若该结点是其双亲结点的右孩子，则生成代码1。</p>
<p>(4)由于生成的编码与要求的编码反序，将所生成的编码反序。</p>
<p>(5)重复步骤(1)~(4)，直到所有结点都回溯完。</p>
<p>反序方法：首先将生成的编码从后向前依次存放在一个临时的一维数组中，并设一个指针start指示编码在该一维数组中的起始位置。当某个叶子结点的编码完成时，从临时的一维数组的start处将编码复制到该字符对应的bits中即可。</p>
<h2 id="哈夫曼解码"><a href="#哈夫曼解码" class="headerlink" title="哈夫曼解码"></a>哈夫曼解码</h2><p>哈夫曼解码过程:从哈夫曼树的根结点出发，依次识别电文的中的二进制编码，如果为0，则走向左孩子，否则走向右孩子，走到叶结点时，就可以得到相应的解码字符。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">void CharSetHuffmanDecoding(HuffmanTree T, char* cd, int n)  </div><div class="line">  &#123;  </div><div class="line">       int p=2*n-2;      //从根结点开始  </div><div class="line">       int i=0;  </div><div class="line">       //当要解码的字符串没有结束时  </div><div class="line">       while(cd[i]!='/0')  </div><div class="line">       &#123;  </div><div class="line">            //当还没有到达哈夫曼树的叶子并且要解码的字符串没有结束时  </div><div class="line">           while((T[p].lchild!=0 &amp;&amp; T[p].rchild != 0) &amp;&amp; cd[i] != '\0')  </div><div class="line">            &#123;  </div><div class="line">                 if(cd[i] == '0')  </div><div class="line">                 &#123;  </div><div class="line">                    //如果是0，则叶子在左子树  </div><div class="line">                    p=T[p].lchild;  </div><div class="line">                 &#125;  </div><div class="line">                 else  </div><div class="line">                 &#123;  </div><div class="line">                    //如果是1，则叶子在左子树  </div><div class="line">                    p=T[p].rchild;  </div><div class="line">                 &#125;  </div><div class="line">                 i++;  </div><div class="line">      &#125;  </div><div class="line">      //如果到达哈夫曼树的叶子时  </div><div class="line">       if(T[p].lchild == 0 &amp;&amp; T[p].rchild == 0)  </div><div class="line">       &#123;  </div><div class="line">           printf("%c", T[p].ch);  </div><div class="line">           p = 2*n-1;  </div><div class="line">        &#125;  </div><div class="line">       else      //如果编号为p的结点不是叶子，那么编码有错  </div><div class="line">        &#123;  </div><div class="line">             printf("\n解码出错! \n");  </div><div class="line">            return;  </div><div class="line">         &#125;  </div><div class="line">   &#125;  </div><div class="line">    printf("\n");  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p> 即二叉搜索树：</p>
<p>  1.所有非叶子结点至多拥有两个儿子（Left和Right）；</p>
<p>  2.所有结点存储一个关键字；</p>
<p>  3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</p>
<p> 如：</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/1.JPG" alt=""></p>
<p>B树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；</p>
<p>否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入</p>
<p>右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</p>
<p>如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树</p>
<p>的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构</p>
<p>（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p>
<p> 如：<br><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/2.JPG" alt=""></p>
<p>但B树在经过多次插入与删除后，有可能导致不同的结构：</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/31.JPG" alt=""></p>
<p>右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的</p>
<p>树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就</p>
<p>是所谓的“平衡”问题；      </p>
<p>实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树</p>
<p>结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的</p>
<p>策略；</p>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h1><p>是一种多路搜索树（并不是二叉的）：</p>
<p>1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；</p>
<p>2.根结点的儿子数为[2, M]；</p>
<p>3.除根结点以外的非叶子结点的儿子数为[M/2, M]；</p>
<p>4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）</p>
<p>5.非叶子结点的关键字个数=指向儿子的指针个数-1；</p>
<p>6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</p>
<p>7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的</p>
<p>子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</p>
<p>8.所有叶子结点位于同一层；</p>
<p>如：（M=3）</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/4.JPG" alt=""></p>
<p>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果</p>
<p>命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为</p>
<p>空，或已经是叶子结点；</p>
<h2 id="B-树的特性："><a href="#B-树的特性：" class="headerlink" title="B-树的特性："></a>B-树的特性：</h2><p>1.关键字集合分布在整颗树中；</p>
<p>2.任何一个关键字出现且只出现在一个结点中；</p>
<p>3.搜索有可能在非叶子结点结束；</p>
<p>4.其搜索性能等价于在关键字全集内做一次二分查找；</p>
<p>5.自动层次控制；</p>
<p>由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少</p>
<p>利用率，其最底搜索性能为：</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/0.JPG" alt=""></p>
<p>其中，M为设定的非叶子结点最多子树个数，N为关键字总数；</p>
<p>所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；</p>
<p>由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占</p>
<p>M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；</p>
<h1 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>1.其定义基本与B-树同，除了：</p>
<p>2.非叶子结点的子树指针与关键字个数相同；</p>
<p>3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树</p>
<p>（B-树是开区间）；</p>
<p>5.为所有叶子结点增加一个链指针；</p>
<p>6.所有关键字都在叶子结点出现；</p>
<p>如：（M=3）<br><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/5.JPG" alt=""></p>
<p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在</p>
<p>非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<h2 id="B-的特性："><a href="#B-的特性：" class="headerlink" title="B+的特性："></a>B+的特性：</h2><p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好</p>
<p>是有序的；</p>
<p>2.不可能在非叶子结点命中；</p>
<p>3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储</p>
<p>（关键字）数据的数据层；</p>
<p>4.更适合文件索引系统；</p>
<h1 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B*树"></a>B*树</h1><p>是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/manesking/6.JPG" alt=""></p>
<p>B<em>树定义了非叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3</p>
<p>（代替B+树的1/2）；</p>
<p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据</p>
<p>复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父</p>
<p>结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</p>
<p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分</p>
<p>数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字</p>
<p>（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之</p>
<p>间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；</p>
<p>所以，B*树分配新结点的概率比B+树要低，空间使用率更高；</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于<br>走右结点；</p>
</li>
<li><p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键<br>字范围的子结点；<br>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
</li>
<li><p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点<br>中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
</li>
<li><p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率<br>从1/2提高到2/3；</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;p&gt;二叉树是每个结点最多有两个子树的有序树。通常子树的根被称作“左子树”（left subtree）和“右子树”（right subtr
    
    </summary>
    
      <category term="算法" scheme="http://dingran.tk/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://dingran.tk/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统的事务处理</title>
    <link href="http://dingran.tk/2017/04/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://dingran.tk/2017/04/09/分布式系统的事务处理/</id>
    <published>2017-04-09T15:18:30.000Z</published>
    <updated>2017-04-09T15:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是一篇关于分布式事务的文章，写的很好"><a href="#这是一篇关于分布式事务的文章，写的很好" class="headerlink" title="这是一篇关于分布式事务的文章，写的很好"></a>这是一篇关于分布式事务的文章，写的很好</h1><p>原文地址<a href="http://coolshell.cn/articles/10910.html" target="_blank" rel="external">http://coolshell.cn/articles/10910.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这是一篇关于分布式事务的文章，写的很好&quot;&gt;&lt;a href=&quot;#这是一篇关于分布式事务的文章，写的很好&quot; class=&quot;headerlink&quot; title=&quot;这是一篇关于分布式事务的文章，写的很好&quot;&gt;&lt;/a&gt;这是一篇关于分布式事务的文章，写的很好&lt;/h1&gt;&lt;p&gt;原文
    
    </summary>
    
      <category term="事务" scheme="http://dingran.tk/categories/%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="事务" scheme="http://dingran.tk/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="分布式" scheme="http://dingran.tk/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>post图片测试</title>
    <link href="http://dingran.tk/2017/03/31/post%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"/>
    <id>http://dingran.tk/2017/03/31/post图片测试/</id>
    <published>2017-03-31T05:59:31.000Z</published>
    <updated>2017-03-31T06:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/post图片测试/default_avatar.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/post图片测试/default_avatar.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
