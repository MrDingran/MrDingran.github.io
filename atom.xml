<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>崎岖的路,走出自己的脚步</title>
  <subtitle>崎岖的路,走出自己的脚步</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dingran.tk/"/>
  <updated>2017-11-04T04:05:35.000Z</updated>
  <id>http://dingran.tk/</id>
  
  <author>
    <name>D.R</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于DTC采用aop添加日志</title>
    <link href="http://dingran.tk/2017/11/04/%E5%85%B3%E4%BA%8EDTC%E9%87%87%E7%94%A8aop%E6%B7%BB%E5%8A%A0%E6%97%A5%E5%BF%97/"/>
    <id>http://dingran.tk/2017/11/04/关于DTC采用aop添加日志/</id>
    <published>2017-11-04T03:50:56.000Z</published>
    <updated>2017-11-04T04:05:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来加个班，主要是对DTC的访问添加日志的统计。之前做了一次日志统计，由于所有的代码都是镶嵌在原来的代码里面，造成代码耦合度很强，一个方法的代码经常超过了200行，关键是的事之前采用的汇总策略，但是准确性经常查了几个百分点，造成数据不太可信。随后经过考虑分析，决定采用AOP的方式进行统计。</p>
<p>开始一切都很顺利，自定义个标签，添加类别，根据对应的类别进行对比统计。貌似没有什么问题了，经过简单的测试也没有问题，统计的数据也很准确。便放到sst环境上进行测试，刚发不多久，就看到有入参为空的现象，开始以为是供应商传参有问题，后续发现不对，而且越来越多，我在本地测试没有发现这种问题呀，经过对比我发现了问题的根源：</p>
<p>这个余位查询没有指定对应的提交方式即既可以用post的方式也可以用get的方式，我之前本地测试使用的便是get方式，get是将参数作为url的一部分，所以没有问题。post的方式是用方法体的一部分作为流的方式进行传递。先说明一点，由于我需要统计分销商，也就说在aop的before层里面，我需要先解析意思post的流，后续进入正式的方法里面，需要在解析一次，那么问题就出现这再次解析里面：httpServletRequest的getRender和getInputStream获取流只能获取一次，这里需要切记。那么找到了问题的根源就想怎么解决，数据肯定是要解析的，所以后续解析不了，只需要将解析后的数据传递下去即可。如果想怎么解决？<br>可以借鉴：<a href="http://www.cnblogs.com/ocean-sky/p/6899613.html" target="_blank" rel="external">http://www.cnblogs.com/ocean-sky/p/6899613.html</a></p>
<p>ok，到了这一步数据解决了，在本地进行压测统计，发现aop的afterreturn统计不了数据，由于我们采用TSP的分布式调用，所以有可能是aop的after失效了，所以我将对应的逻辑进行重构，再次进行spring托管，进行aop统计，这里彻底解决了问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来加个班，主要是对DTC的访问添加日志的统计。之前做了一次日志统计，由于所有的代码都是镶嵌在原来的代码里面，造成代码耦合度很强，一个方法的代码经常超过了200行，关键是的事之前采用的汇总策略，但是准确性经常查了几个百分点，造成数据不太可信。随后经过考虑分析，决定采用AO
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>DTC添加统计日志</title>
    <link href="http://dingran.tk/2017/11/01/DTC%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E6%97%A5%E5%BF%97/"/>
    <id>http://dingran.tk/2017/11/01/DTC添加统计日志/</id>
    <published>2017-11-01T03:46:11.000Z</published>
    <updated>2017-11-01T05:08:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>11.1号，新的一个月了，一晃就过了一个月，再晃晃就过年了。</p>
<p>10.1回来后主要是价格的修复操作，找到的问题的根源后，经过一个月的数据刷新，现在价格问题几乎不再出现，主要是对系统内部的一些功能的调整。</p>
<p>之前需要统计DTC余位查询的调用功能的数据、代理ip的使用数据以及各个分销商的调用数据，由于DTC之前没有这个功能，只能通过TSP的平台上直接看接口的总体调用次数，不能以各种维度去统计分析数据。</p>
<p>之前由于领导紧急要用，便紧急做了一个统计功能。这个统计功能什么都有，各种维度，但是需要在原来的代码里面穿插大量的统计代码。没错，就是这种土方法，由于运营等还要添加各种其他维度，后面还需要继续添加，后果可想而知。本来就很乱的代码，如果在里面再继续添加这种统计代码，后面就不用维护了。</p>
<p>上述统计的方法虽然方便，却是对原代码有很大的入侵性，造成高度耦合性。后期发现有的数据统计的都差除了3个百分点。还不准确，无法交代。为此我想起了spring的AOP功能。</p>
<p>spring的aop功能就是在方法前执行一段逻辑，方法执行完后执行一段逻辑，而且采用的是代理模式，只需要配置一段代码便可让原代码在无感知的情况下，完成统计工作。</p>
<p>配合切面需要谨慎考虑，总体来说需要统计的就那么几个类，但是却需要统计各个维度，比如价格查询、经停站查询、余位查询、抢票查询等，所以应用spring的自定义annotation来设置就在合适不过了，只要在自定义标签上添加对应的type就可以及时分辨出来需要统计的维度，后续需要再添加任何维度，只需要在没枚举中添加这个维度，然后在对应的处理标签中扩展对应的逻辑即可，非常方便。原来穿插在代码的多行代码，只需要在方法的头部添加个标签，标签配置type就搞定了，可侵入性非常低，耦合性也非常低。</p>
<p>下周上线，后续将对牛抢票开展进一步操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;11.1号，新的一个月了，一晃就过了一个月，再晃晃就过年了。&lt;/p&gt;
&lt;p&gt;10.1回来后主要是价格的修复操作，找到的问题的根源后，经过一个月的数据刷新，现在价格问题几乎不再出现，主要是对系统内部的一些功能的调整。&lt;/p&gt;
&lt;p&gt;之前需要统计DTC余位查询的调用功能的数据、
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>9.24号价格问题总结</title>
    <link href="http://dingran.tk/2017/10/14/9-24%E5%8F%B7%E4%BB%B7%E6%A0%BC%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/10/14/9-24号价格问题总结/</id>
    <published>2017-10-14T06:41:13.000Z</published>
    <updated>2017-10-14T06:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>9.20左右上线了竞品的数据查询分析的一部分代码，这个功能是用来在紧急的情况下，可以采用竞品的数据来保证我们火车票的业务正常流转，在本地进行测试的时候一切都很顺利，后来上线后，我将数据进行按照比例进行分配给竞品查询，一切看起来都是很顺利的。</p>
<p>后来由于出现了价格的问题，车次查出来的价格都是乱七八糟的，影响了很多业务的进行。随即关闭竞品的数据查询。由于临近10.1，我又提前请了2天假回家，这10.1期间价格问题层出不穷，这时候我还是不知道价格的问题出现在哪里。这段期间内由技术支持来进行手动刷取价格保证业务的正常流转。</p>
<p>10.1假期过后，价格的问题成了我的首要任务，首先我将价格进行添加origin字段即添加价格的来源，这样我们就可一眼看出这个错误的价格来源自哪里，因为我们的价格来源途径不仅只有一条，所以上线后，我看到了线上的数据随即进行了更新，新抓下来的价格几乎是没有问题的。</p>
<p>再次查看对比相同车次的不同团期的价格，发现了一个大问题，抓取价格是按照trainno和fromstationno还有tostationno，三个部分组成的。但是数据库里面这三个要素是相同的，但是对应的站站三字码却是不同的，这就是说，价格抓取的不对。经过仔细分析，这三个在12306都是提供的字段，唯一不提供的就是对数据竞品数据查询，瞬间知道了一切来源，原来是自己无意之间闯了这么个大祸，还好及时关闭了。为自己犯下这么低级的错误而羞愧。</p>
<p>虽说这次问题比较大，但是意义很深刻，为什么说呢？因为12306的trainno是可变的，比如G1对应的trainno可能不知道哪一天就变掉了，而且这个trainno却是查询价格和经停站必备的字段。所以在用竞品查询的时候如果取不对trainno或者fromNo还有toNo取错了的话，那么整个脏数据就会出现。</p>
<p>根据如上的分析，我找出了对应的策略，将from三字码和to三字码放到缓存里面，如果查出的价格的站站不是我要获取的站站三字码，价格就要重新抓取，虽然这是个十分漫长的数据更新过程，不过却可以最大程度减少问题。</p>
<p>现在经过几天的价格清洗，可以看到数据正在有序的恢复，下周上线后，数据将彻底完善。为此我还开发了价格自动前推后推功能，可以自动将30天的数据全部更新一遍，但是消耗代理ip的数据实在太大了，所以在十分紧急或者资源够用的情况下可以开启。</p>
<p>请铭记此次问题的前因后果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9.20左右上线了竞品的数据查询分析的一部分代码，这个功能是用来在紧急的情况下，可以采用竞品的数据来保证我们火车票的业务正常流转，在本地进行测试的时候一切都很顺利，后来上线后，我将数据进行按照比例进行分配给竞品查询，一切看起来都是很顺利的。&lt;/p&gt;
&lt;p&gt;后来由于出现了价格
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>10.1这段期间小结</title>
    <link href="http://dingran.tk/2017/10/12/10-1%E8%BF%99%E6%AE%B5%E6%9C%9F%E9%97%B4%E5%B0%8F%E7%BB%93/"/>
    <id>http://dingran.tk/2017/10/12/10-1这段期间小结/</id>
    <published>2017-10-12T06:02:42.000Z</published>
    <updated>2017-10-12T06:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>10.1眨眼就过去了，回家呆了9天左右，算是一个小长假了，走之前不知道什么情况价格出现了很多脏数据。数据中心本身就是个源头，结果源头的数据乱套了就废了。途牛线、分销线都开始报价格不准，各种大王过来捅呀。。。所以整个假期过的都不安分。</p>
<p>坐飞机刚回家的第一天晚上，运维打电话说我们的调用线上的公共mq了，我查找一下代码果然在一个地方调用了，幸好我机智做了一个开关，关上了算是消停了很多。第二天老大开始捅价格问题。不光是途牛的，jd的捅了最厉害了。由于一时没有更好的解决方案，所以只能先挺着。</p>
<p>回来了就着手开始解决价格的问题。我先出了一个方案，将价格问题的背景以及出现问题的可能性进行剖析还有即将应对的方案进行详细阐述。回来就开了个会，我详细将我的方案和大家进行讨论，经过大家的统一定夺后，就开始进行开发操作。</p>
<ul>
<li>价格抓取还是以12306为准</li>
<li>增加微信接口的应用性</li>
<li>竞品的数据先作为备用</li>
<li>返回缓存的时候一定要取价格的最新缓存</li>
<li>价格小于0.5的全部滤掉，不显示</li>
<li>价格自动校验正确 差距太大需要警示</li>
<li>价格添加来源 后期可以一眼看出价格的错误来源进行有效的分析</li>
</ul>
<p>昨天的上线还是很顺林的，价格修复操作开始不断的进行，通过elk日志，可以看到我们的价格缓存有很多的错误数据，还有一部分是12306给出的价格是错误的，但是不影响售卖。昨天还有几单说要刷价格，今天几乎没有了，说明价格的准确性已经取得初步的胜利，后面将继续进行观察。</p>
<p>PS:12306最近又有新的幺蛾子，不仅在G\D\C上增加了选座的功能，而且还提供了可以进行中转的功能，后期对应的需求肯定开始来了，真是应接不暇，说好的同名支付呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;10.1眨眼就过去了，回家呆了9天左右，算是一个小长假了，走之前不知道什么情况价格出现了很多脏数据。数据中心本身就是个源头，结果源头的数据乱套了就废了。途牛线、分销线都开始报价格不准，各种大王过来捅呀。。。所以整个假期过的都不安分。&lt;/p&gt;
&lt;p&gt;坐飞机刚回家的第一天晚上，
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>9.18号12306巨坑来袭</title>
    <link href="http://dingran.tk/2017/09/22/9-18%E5%8F%B712306%E5%B7%A8%E5%9D%91%E6%9D%A5%E8%A2%AD/"/>
    <id>http://dingran.tk/2017/09/22/9-18号12306巨坑来袭/</id>
    <published>2017-09-22T08:16:41.000Z</published>
    <updated>2017-09-22T08:26:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>9.18号，看起一切都十分正常，我准备开始研究火车票的架构推进策略。然而客服报了一单订单价格出现异常。起初还没有在意这是什么导致的，查询这个站站对后发现，12306居然没有给这个车次赋值价格，剩余的几个车次都没有价格，我的天啊，发生了生么？</p>
<p>查询app端发现价格也没有，这个很严重的呀，这样会导致我们的火车票的车次列表的信息显示不完整，不光是影响了途牛线，连京东也叫了起来，发了100+个订单过来，说是占位失败。大批量的站站对都是从哈尔滨西发车的都有问题。查看相关站站对，发现有的价格涨了不少，还有一些是价格为空的。这次10.1，12306增加了部分的临时车次，也许12306的相关车次也在进行相关的调整。</p>
<p>此次影响的范围已经超过了我的预计，必须立马马上进行修复方案。12306的价格已经不能作为唯一的价格来源，为此我研究了多种方案后，进行相关相似性对比，找出了最匹配的方案，立马开始开发编码，用了不到一天的努力，价格开始大规模修复，截止目前，几乎不再有价格的问题。</p>
<p>祈祷12306稳定一些 好吧啦！！！在这么折磨真要疯了的节奏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9.18号，看起一切都十分正常，我准备开始研究火车票的架构推进策略。然而客服报了一单订单价格出现异常。起初还没有在意这是什么导致的，查询这个站站对后发现，12306居然没有给这个车次赋值价格，剩余的几个车次都没有价格，我的天啊，发生了生么？&lt;/p&gt;
&lt;p&gt;查询app端发现价
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>爬取12306cookie的总结</title>
    <link href="http://dingran.tk/2017/09/13/%E7%88%AC%E5%8F%9612306cookie%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/09/13/爬取12306cookie的总结/</id>
    <published>2017-09-13T03:01:06.000Z</published>
    <updated>2017-09-13T08:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>9.4号，所有的供应商全部挂掉了，就剩一家还在苟延残喘，随后一天后，供应商全部恢复，不得不赞叹，供应商的应对策略还是很厉害的。我们的直连趴窝了好几天后，经过艰难的摸索终于可以试营业了。之前一直委以重任的app反刷现在也停下来了，降到现在的1%左右的使用率，之前还有大概70以上呢。</p>
<p>造成这么多的事故，肯定是12306采用了或者更改了什么机制导致了大家都集体崩溃了。这边DTC的查询量也被封的十分严重，所以找到应对方法十分重要。首先一般查询都是从query接口开始的，但是12306一般都是从log接口开始的，之前也一直没有在意这个接口到底是干什么的，一直认为就是在记录一些日志。最近和在飞飞研究他那块问题的时候，发现有些接口变了，最主要的是12306开始往回写了一些cookie的东西，这引起了我的注意。那么经过推敲，我觉得我这边肯定也是返回了cookie的东西。我将拼接好的链接，放到另一个浏览器采用无痕模式访问，结果直接返回悲剧了，ok，看来是12306发现了我们的非法访问，并且在返回结果返回“非法请求”，有点搞笑。怎么让我们的请求变成合理请求呢？就得从log接口入手了。</p>
<p>首先将浏览器缓存包括cookie全部清除，调用log接口，发现返回结果还是和之前一样，没没有发生任何变化，但是在response的header里面多了set-cookie，我们这边爬取，直接忽略cookie，可能就直接12306识别出来了。所以现在本地做测试，先访问log接口，抓取cookie，然后在调用query接口的时候，带上这些cookie，重启服务器，再次调用接口，但是发现，还是发现非法请求，咦？啥问题，不是该有的都有了么？肯定是什么东西还是被察觉了，经过询问飞飞（他踩了好久的坑），他现在可以使用了，我问题他怎么使用的cookie，他说用他用的cookiestore，我则使用的字符串拼接，可能是这个原因么？</p>
<p>我将log接口返回的cookie，封装成cookiestore，再次将cookiestore载入httpclient，发起请求，发现这次不是非法请求了，而是网络繁忙了。ok，又向胜利近了一步，剩下的再次观察浏览器cookie，发现还有很多其他静态cookie，都是用来保存上次访问的信息的，我直接将这些cookie动态生成，封装成cookiestore，一起在访问query接口，一起带给服务器，再次尝试请求query接口，嗯，终于返回结果了，通过这一步步的尝试，终于摸清楚了12306到底搞了什么名堂。</p>
<p>后续app反刷等也必须采用这种方式进行处理，否则无法获取真正的数据，我们就断了一条路获取数据，虽然我们有很多的路获取数据^_^</p>
<p>PS:今天下午，之前一直搁置的需求找回12306密码，之前由于种种原因始终没有通过最后的请求，下午闲来没事采用上面的cookiestore的方式，认真的将每个cookie小心导入，最后，binggo，成功了，终于最近觉得做了一件有点意义的事情。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9.4号，所有的供应商全部挂掉了，就剩一家还在苟延残喘，随后一天后，供应商全部恢复，不得不赞叹，供应商的应对策略还是很厉害的。我们的直连趴窝了好几天后，经过艰难的摸索终于可以试营业了。之前一直委以重任的app反刷现在也停下来了，降到现在的1%左右的使用率，之前还有大概70以
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>记20170905的上线总结</title>
    <link href="http://dingran.tk/2017/09/05/%E8%AE%B020170905%E7%9A%84%E4%B8%8A%E7%BA%BF%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/09/05/记20170905的上线总结/</id>
    <published>2017-09-05T07:30:06.000Z</published>
    <updated>2017-09-05T07:51:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>9月4号，上午都是风平浪静的，最近12306一直在搞什么同名支付，这边各个组也都积极应对，否则后面都无法卖票了。</p>
<p>中午刚吃饭回来，就发现12306接口响应速度非常慢，途牛火车票这边几乎查询不出来任何数据。比较恶心的是12306不返回数据也就算了呗，结果返回了为空的结果，其实这个站站对是有车次的呀，数据中心的基础数据几乎都被12306给打乱了。</p>
<p>本来我就预想这要做一个容灾的机制：现在所有的数据都是从12306爬下来的，如果12306加紧封ip的步骤，我们就会面临很被动的局面，而事实也正是如此，在8.23号以来，12306不断提升封ip的步伐，最初一天只会封我们几百次请求，到现在几乎都把我们逼到死胡同了，而9.4号这天，12306的不知道是上线还是在干什么，首先余位查询接口接连变了两次，而后，余位查询全部都是访问网络繁忙，再往后什么也查不出来了。作为12306的“分销商”，12306的可用性几乎连2个9都达不到，如果是上线或者修改什么在白天是不是也太儿戏了，特别是在10.1这么个买票小高峰的时间段。</p>
<p>容灾机制其实我已经构思完毕了，只是这个接口返回的数据和我现有的数据有些冲突，所谓冲突的点就是原能够提供的数据，这个新接口不能提供或者根本没有，而我们的接口返回的数据这些参数还必须都要有。我准备在研究一段时间，但是9.4号这一天突然12306的查询接口不可用了，逼着我把这个接口给紧急上线了，因为我们的车次列表根本不显示任何数据，紧急发布一版了后，车次列表可以暂时显示，所有的线上流量全部走新接口，由于是紧急上线，线上的接口还是有很多问题的，有些没有提供的参数需要我进行查找、计算得出来的。并且12306的车次还有暂售、停运、起售和我们自己的预售。这么多状态少了一个都不行，都会影响客人的下单引起客人的投诉。</p>
<p>9.4号注定不是平凡的一天，由于12306的变动，所有的供应商出票10家有9家全部瘫痪，造成订单几乎卡在占位中，后面分销商不停的催、我们催供应商。到了下午六点以后，12306的接口有所恢复，但是查询的效果还是很低，到了今天算是终于告于一个段落。</p>
<p>祈祷12306不要搞什么花样，还有这个同名支付不要再引起一波动荡！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9月4号，上午都是风平浪静的，最近12306一直在搞什么同名支付，这边各个组也都积极应对，否则后面都无法卖票了。&lt;/p&gt;
&lt;p&gt;中午刚吃饭回来，就发现12306接口响应速度非常慢，途牛火车票这边几乎查询不出来任何数据。比较恶心的是12306不返回数据也就算了呗，结果返回了为
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>spring事务失效原因之一</title>
    <link href="http://dingran.tk/2017/08/30/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%E4%B9%8B%E4%B8%80/"/>
    <id>http://dingran.tk/2017/08/30/spring事务失效原因之一/</id>
    <published>2017-08-30T06:28:58.000Z</published>
    <updated>2017-08-30T06:36:01.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>有一种情况会导致spring的aop事务失效：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AService</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">   </div><div class="line"><span class="meta">@Service</span>()  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl1</span> <span class="keyword">implements</span> <span class="title">AService</span></span>&#123;  </div><div class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED)  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.b();  </div><div class="line">    &#125;  </div><div class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在this.b()调用b方法中，b的事务是不会生效的原因是这种调用方式无法实现aop的增强方式<br><img src="http://dl.iteye.com/upload/attachment/0066/6247/d33ee177-cf3f-39cc-befe-533306b0715f.jpg" alt="http://dl.iteye.com/upload/attachment/0066/6247/d33ee177-cf3f-39cc-befe-533306b0715f.jpg"></li>
</ol>
<p>3、解决方案<br>此处a方法中调用b方法时，只要通过AOP代理调用b方法即可走事务切面，即可以进行事务增强，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;  </div><div class="line">aopProxy.b();<span class="comment">//即调用AOP代理对象的b方法即可执行事务切面进行事务增强  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>判断一个Bean是否是AOP代理对象可以使用如下三种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AopUtils.isAopProxy(bean)        ： 是否是代理对象；</div><div class="line">AopUtils.isCglibProxy(bean)       ： 是否是CGLIB方式的代理对象；</div><div class="line">AopUtils.isJdkDynamicProxy(bean) ： 是否是JDK动态代理方式的代理对象；</div></pre></td></tr></table></figure>
<p>3.1、通过ThreadLocal暴露Aop代理对象</p>
<p>1、开启暴露Aop代理到ThreadLocal支持（如下配置方式从spring3开始支持）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>/&gt;</span><span class="tag">&lt;<span class="name">!—注解风格支持--</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">!—xml风格支持--</span>&gt;</span></div></pre></td></tr></table></figure>
<p>2、修改我们的业务实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.b();-----------修改为---------&gt;((AService) AopContext.currentProxy()).b();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;有一种情况会导致spring的aop事务失效：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div 
    
    </summary>
    
      <category term="spring" scheme="http://dingran.tk/categories/spring/"/>
    
    
      <category term="spring" scheme="http://dingran.tk/tags/spring/"/>
    
      <category term="事务" scheme="http://dingran.tk/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖的三种方式</title>
    <link href="http://dingran.tk/2017/08/22/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://dingran.tk/2017/08/22/Spring循环依赖的三种方式/</id>
    <published>2017-08-22T06:43:03.000Z</published>
    <updated>2017-08-22T06:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://blog.csdn.net/u010644448/article/details/59108799" target="_blank" rel="external">http://blog.csdn.net/u010644448/article/details/59108799</a></p>
<h1 id="第一种：构造器参数循环依赖"><a href="#第一种：构造器参数循环依赖" class="headerlink" title="第一种：构造器参数循环依赖"></a>第一种：构造器参数循环依赖</h1><p>Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持<br>在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出<br>BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。</p>
<p>首先我们先初始化三个Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> StudentB studentB ;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentB</span><span class="params">(StudentB studentB)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.studentB = studentB;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentA</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentA</span><span class="params">(StudentB studentB)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.studentB = studentB;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> StudentC studentC ;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentC</span><span class="params">(StudentC studentC)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.studentC = studentC;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentB</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentB</span><span class="params">(StudentC studentC)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.studentC = studentC;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentC</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> StudentA studentA ;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudentA</span><span class="params">(StudentA studentA)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.studentA = studentA;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentC</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentC</span><span class="params">(StudentA studentA)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.studentA = studentA;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，上面是很基本的3个类，，StudentA有参构造是StudentB。StudentB的有参构造是StudentC，StudentC的有参构造是StudentA ，这样就产生了一个循环依赖的情况，<br>我们都把这三个Bean交给Spring管理，并用有参构造实例化</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentA"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentB"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"c"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentC"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面是测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/zfx/student/applicationContext.xml"</span>);  </div><div class="line">        <span class="comment">//System.out.println(context.getBean("a", StudentA.class));  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果报错信息为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:   </div><div class="line">    Error creating bean with name &apos;a&apos;: Requested bean is currently in creation: Is there an unresolvable circular reference?</div></pre></td></tr></table></figure>
<p>如果大家理解开头那句话的话，这个报错应该不惊讶，Spring容器先创建单例StudentA，StudentA依赖StudentB，然后将A放在“当前创建Bean池”中，此时创建StudentB,StudentB依赖StudentC ,然后将B放在“当前创建Bean池”中,此时创建StudentC，StudentC又依赖StudentA， 但是，此时Student已经在池中，所以会报错，，因为在池中的Bean都是未初始化完的，所以会依赖错误 ，（初始化完的Bean会从池中移除）</p>
<h1 id="第二种：setter方式单例，默认方式"><a href="#第二种：setter方式单例，默认方式" class="headerlink" title="第二种：setter方式单例，默认方式"></a>第二种：setter方式单例，默认方式</h1><p>如果要说setter方式注入的话，我们最好先看一张Spring中Bean实例化的图</p>
<p><img src="http://img.blog.csdn.net/20170301154450018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY0NDQ0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>如图中前两步骤得知：<strong>Spring是先将Bean对象实例化之后再设置对象属性的</strong></p>
<p>修改配置文件为set方式注入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">&lt;!--scope="singleton"(默认就是单例方式)  --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentA"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentB"</span> <span class="attr">ref</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentB"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentC"</span> <span class="attr">ref</span>=<span class="string">"c"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentC"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentA"</span> <span class="attr">ref</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>下面是测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/zfx/student/applicationContext.xml"</span>);  </div><div class="line">        System.out.println(context.getBean(<span class="string">"a"</span>, StudentA.class));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">com.zfx.student.StudentA@1fbfd6</div></pre></td></tr></table></figure>
<p>为什么用set方式就不报错了呢 ？<br>    我们结合上面那张图看，Spring先是用构造实例化Bean对象 ，此时Spring会将这个实例化结束的对象放到一个Map中，并且Spring提供了获取这个未设置属性的实例化对象引用的方法。   结合我们的实例来看，，当Spring实例化了StudentA、StudentB、StudentC后，紧接着会去设置对象的属性，此时StudentA依赖StudentB，就会去Map中取出存在里面的单例StudentB对象，以此类推，不会出来循环的问题喽、</p>
<p>下面是Spring源码中的实现方法，。以下的源码在Spring的Bean包中的DefaultSingletonBeanRegistry.Java类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance（缓存单例实例化对象的Map集合） */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);  </div><div class="line">      </div><div class="line">    <span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory（单例的工厂Bean缓存集合） */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&gt;(<span class="number">16</span>);  </div><div class="line">      </div><div class="line">    <span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance（早期的单身对象缓存集合） */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);  </div><div class="line">      </div><div class="line">    <span class="comment">/** Set of registered singletons, containing the bean names in registration order（单例的实例化对象名称集合） */</span>  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">64</span>);  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 添加单例实例 </div><div class="line">     * 解决循环引用的问题 </div><div class="line">     * Add the given singleton factory for building the specified singleton </div><div class="line">     * if necessary. </div><div class="line">     * &lt;p&gt;To be called for eager registration of singletons, e.g. to be able to </div><div class="line">     * resolve circular references. </div><div class="line">     * <span class="doctag">@param</span> beanName the name of the bean </div><div class="line">     * <span class="doctag">@param</span> singletonFactory the factory for the singleton object </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory singletonFactory)</span> </span>&#123;  </div><div class="line">        Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);  </div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;  </div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;  </div><div class="line">                <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);  </div><div class="line">                <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);  </div><div class="line">                <span class="keyword">this</span>.registeredSingletons.add(beanName);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="第三种：setter方式原型，prototype"><a href="#第三种：setter方式原型，prototype" class="headerlink" title="第三种：setter方式原型，prototype"></a>第三种：setter方式原型，prototype</h1><p>修改配置文件为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentA"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentB"</span> <span class="attr">ref</span>=<span class="string">"b"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentB"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentC"</span> <span class="attr">ref</span>=<span class="string">"c"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"com.zfx.student.StudentC"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentA"</span> <span class="attr">ref</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>scope=”prototype” 意思是 每次请求都会创建一个实例对象。两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。<br>测试用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"com/zfx/student/applicationContext.xml"</span>);  </div><div class="line">        &lt;strong&gt;<span class="comment">//此时必须要获取Spring管理的实例，因为现在scope="prototype" 只有请求获取的时候才会实例化对象&lt;/strong&gt;  </span></div><div class="line">        System.out.println(context.getBean(<span class="string">"a"</span>, StudentA.class));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:   </div><div class="line">    Error creating bean with name &apos;a&apos;: Requested bean is currently in creation: Is there an unresolvable circular reference?</div></pre></td></tr></table></figure>
<p>为什么原型模式就报错了呢 ？<br>对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容<br>器不进行缓存，因此无法提前暴露一个创建中的Bean。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;http://blog.csdn.net/u010644448/article/details/59108799&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/u010644448/arti
    
    </summary>
    
      <category term="spring" scheme="http://dingran.tk/categories/spring/"/>
    
    
      <category term="spring" scheme="http://dingran.tk/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>牛抢票关于HASH散列分析总结</title>
    <link href="http://dingran.tk/2017/08/11/%E7%89%9B%E6%8A%A2%E7%A5%A8%E5%85%B3%E4%BA%8EHASH%E6%95%A3%E5%88%97%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/08/11/牛抢票关于HASH散列分析总结/</id>
    <published>2017-08-11T08:11:01.000Z</published>
    <updated>2017-08-11T08:33:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近抢票的订单明显增加了好多，每个抢票都要在规定时间进行查询DTC再去12306查询判断余票，然后根据余位的数量进行分单。</p>
<p>随着订单的不断增加，比如当前有1W单，需要在一分钟全部重新查一遍，那么怎么保证所有的订单都能查到呢？之前做的是将订单根据时间戳与60作取余的操作，然后根据余数进行散列到某一个时间进行查询，但是从DTC的角度看OCS查询的分布，发现非常不平均，比如在1~10秒之间几乎没有请求，在30~40秒之间每秒的请求几乎成百上千，这么不平衡的查询造成一个非常严重的问题—DTC有限流，超过限流的部分都将被降级，那么对于OCS来说，这些被降级的数据都是不准确，拿这个数据进行出票站位的话就显得非常无奈。所以ocs的散列均衡就显得非常重要，因为DTC的限流就是根据OCS的散列平均值来设置的。</p>
<p>那怎么整改呢？这时候我想到之前看1.8的concurrentHashmap的一个想法就是数组链表，就是在向map里面放数据的时候进行hash然后散列，但是总是不可避免发生碰撞，map在put的时候，如果发现hash的位置已经有值了，就变成链表，如果链表的长度超过8，就变成红黑树…我们这个不用这么复杂，我们使用hash的散列的时候，发现该位置有值的时候，就在这个位置放置List，比如总量10000，散列到30秒，我们就准备30个捅，平均每秒散列333个左右，每个桶的容量也就是333，那么当散列到这个位置的时候发现桶的容量已经到达333的时候，就放到下一个桶，判断下一个桶的数量是否到达333，如果下一个桶也到333就在放到下一个。。。以此类推。总会放到平均的位置。这里没有使用rehash的操作，因为我测试起来效果不是很明显，并且我这边散列的时间都是很短的，没必要进行rehash操作。</p>
<p>经过写个例子进行压测，发现每次散列的请求数差距不会超过10个，对于10个请求差距已经是很好的，已经满足我的需要，如果想让差距更短，就需要在调节一下各个值得比例就可以了。</p>
<p>非常好，再接再厉。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近抢票的订单明显增加了好多，每个抢票都要在规定时间进行查询DTC再去12306查询判断余票，然后根据余位的数量进行分单。&lt;/p&gt;
&lt;p&gt;随着订单的不断增加，比如当前有1W单，需要在一分钟全部重新查一遍，那么怎么保证所有的订单都能查到呢？之前做的是将订单根据时间戳与60作取
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>7月总结</title>
    <link href="http://dingran.tk/2017/08/01/7%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/08/01/7月总结/</id>
    <published>2017-08-01T02:25:11.000Z</published>
    <updated>2017-08-01T03:03:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>8.1号，迎来了8月份，浑浑噩噩的度过了七月份，这个月做了很多事，有失落也有收获。</p>
<p>七月伊始，妈妈来上海了，我在上海工作都4个年头了，妈妈还是头一次来看我，这要是在我第一年的时候，那都不敢想呀，隔断，连个落脚的地方都没有，蓦然回首都是泪呀，这的不想回忆了。</p>
<p>京东接入途牛火车票已经有一段时间了，天天吵吵着数据这不准，那也不准。没错，确实有些数据不准，这从我的理解都是系统的漏洞导致的，极大部分是开发人员在使用场景没有考虑周全导致的，比如：一个站站对不存在，如何判断不存在？只有12306返回没有，才算车次不存在，如果我们查询12306，查询失败了，就应该返回数据刷新中。看是很简单的道理，但是真的放到编码当中，就会发现控制起来很麻烦，首先以缓存问媒介，前面设置闭锁，后面查询抓取，释放闭锁，然后前面在查询缓存判断缓存是否更新，这里就要判断缓存是真的没有还是访问代理失败了还是被12306屏蔽了呢？纵有千万场景，解决方案是有的，这个问题在之前，根本不是问题，因为数据准确性和速度是首要的。这两项被我改的已有很大的改观后，那么这种数据刷新中和车次不存在自然而然就上台了。</p>
<p>JD对数据的准确性要求很高，我们只能从自身上去解决，尽量提高他们的要求，毕竟他们是金主，但是和我无关，我的职责就是保证我负责的系统的高效、准确的提供数据。</p>
<p>这段时间的技术支持还有丢车次、余位数据不刷新等问题，我查看了一下，大概都是遇到系统瓶颈，DTC的系统瓶颈就是对查询量太大导致线程池很长时间释放，堆积到queue里面。这段时间我对线程池的理解又深刻了一点。线程池，很好的工具，不会导致过量线程出现，但是如何高效利用是否想过？如何配置coreSize？经常遇到一个线程池忙的要死，剩下90%的线程池闲的要死，最多启动1个线程或者active count的线程都是0，是不是有点浪费了。你可能会想到我直接开个500的线程，大家一起用不是更好么？如果开启这么多，系统一下就要启动这么多，如果系统只是一瞬间用到500，多数都是100多有，那么就有400浪费。每个线程池负责自己的业务模块，所以使用场景不同，对CPU的控制也是不同的，所以要做的是在你闲置的情况下，帮我干点事，你忙了，我就不用你了。</p>
<p>这次还做了一件事就是对价格和经停站使用MQ队列进行分布式抓取。价格和经停站抓取的量很多，而且远远超过余位的查询量，自从我把代理ip的统计做出来之后就会发现，80%的代理ip都在抓取价格和经停站，而且代理ip被封的概率很高。另外一个原因是量太大直接导致线程池溢出，因为这已经超出了合理范围，并且价格抓取不全，一个车次10个价格，有时候会抓取6个下来，剩下4个就丢了，也没有重试操作。根据这个特点，使用免费代理ip去抓取价格经停站，使用mq去分发要抓取的数据，平衡到所有的实例上，压力瞬间被缩小化，再充分利用线程池的coresize，现在价格几乎实现秒抓，抓取失败再通过mq重新抓取，保证价格平稳落地，方便后面进行查询。</p>
<p>经过上面多方面的改动，现在系统已经平稳的运行，通过统计数据，可以看出数据刷新中的比例已经由2%降到了0.2%，这是一个很客观的数字，也是很合理的水平，DTC现在已经平稳的运行一段时间，线程总数保持在1200~1300左右，堆内存保持2g-3g之间，一切都在掌控之中。</p>
<p>在压测测试环境的时候，我以6000W的标准进行压测，每秒30个请求访问接口，观看DTC的各项指标，除了线程升高和内存升高点，线程池等像没发生什么事情一样，这主要是尽量不让线程处理耗时太长，否则，就会导致瓶颈的出现。</p>
<p>8月，我来了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;8.1号，迎来了8月份，浑浑噩噩的度过了七月份，这个月做了很多事，有失落也有收获。&lt;/p&gt;
&lt;p&gt;七月伊始，妈妈来上海了，我在上海工作都4个年头了，妈妈还是头一次来看我，这要是在我第一年的时候，那都不敢想呀，隔断，连个落脚的地方都没有，蓦然回首都是泪呀，这的不想回忆了。&lt;/
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>取舍难题？</title>
    <link href="http://dingran.tk/2017/07/31/%E5%8F%96%E8%88%8D%E9%9A%BE%E9%A2%98%EF%BC%9F/"/>
    <id>http://dingran.tk/2017/07/31/取舍难题？/</id>
    <published>2017-07-31T08:20:29.000Z</published>
    <updated>2017-07-31T08:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近前端接口的火车票查询列表被刷了，每天到13点左右的流量会提升2~3倍，这给DTC的查询带来了极大的压力，虽然DTC有限流降级的策略，但是这么大的流量直接导致所有的查询几乎无效化。</p>
<p>现在架构是PC、M站、APP等通过RIS查询DTC获取火车票车次列表，分销商直接接入DTC查询火车车次列表，现在我的想法是：在RIS端限流，将查询波峰给削掉，进入DTC的是平缓的稳定的，现有情况是RIS的高峰直接拉起DTC的查询高峰，导致服务器压力骤然升高。这不光影响前段的查询，也导致分销商的查询不准。根据我得想法，可以保证DTC的查询准确性，分销商不受影响，由于RIS被限流，那么将会影响前端等查询的准确性，这个是现在没办法解决的，因为没有办法区分正常的ip还是恶意的ip。</p>
<p>还有一种就是保持现状，对ip进行限制，但是现在ip根本限制不住，人家攻击你也不会使用单一Ip等着让你封，所以现在每天还是会有一段时间被人家刷的接口直接爆红。</p>
<p>有一个例子：马上就要发洪水了，你最喜爱的两只狗在河里面洗澡，你知道洪水来了后发现你只能救一只（别和说你一只手拎一只或者一声口哨两只狗全颠颠跑到你身边），那么你是救一只还是看着他们全部被冲走呢？</p>
<p>你会有更好的解决办法么？</p>
<p>人生有舍有得，舍得舍得，没有舍哪来得？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近前端接口的火车票查询列表被刷了，每天到13点左右的流量会提升2~3倍，这给DTC的查询带来了极大的压力，虽然DTC有限流降级的策略，但是这么大的流量直接导致所有的查询几乎无效化。&lt;/p&gt;
&lt;p&gt;现在架构是PC、M站、APP等通过RIS查询DTC获取火车票车次列表，分销商
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>DTC线程池整合利用</title>
    <link href="http://dingran.tk/2017/07/29/DTC%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B4%E5%90%88%E5%88%A9%E7%94%A8/"/>
    <id>http://dingran.tk/2017/07/29/DTC线程池整合利用/</id>
    <published>2017-07-29T05:54:42.000Z</published>
    <updated>2017-07-29T06:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直再做DTC系统的整合工作，我将价格与经停站由原来的单个JVM去抓取改为使用MQ去操作。这样做的原因是有的查询车次比较多，造成查询的价格比较多，经停站比较多，单个JVM不一定能够及时处理掉，经常会被线程池扔掉了，造成有些资源的数据抓取不全。</p>
<p>经过压测查看各个线程池的状况得出一个结论：忙的忙死，闲的闲死。有什么办法能让所有的线程池全部调度起来呢？特别是价格抓取的时候由于采用免费代理ip去check，造成需要多次查询才能得出最终结果，而这段期间是不会释放掉线程造成线程堵塞。还有一个就是免费代理ipcheck的时候也是这样的，queue的size经常堆到最大值。</p>
<p>于是我整合所有的线程池，集中到一个方法中，判断当前线程池是否闲置，如果闲置那么就替我做些事情，安排好使用策略，而不影响这个线程池的正常的业务。</p>
<p>改好后，经过测试压测，已经堆积的线程池，现在情况得到了很大的改善，而且不影响正常的使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直再做DTC系统的整合工作，我将价格与经停站由原来的单个JVM去抓取改为使用MQ去操作。这样做的原因是有的查询车次比较多，造成查询的价格比较多，经停站比较多，单个JVM不一定能够及时处理掉，经常会被线程池扔掉了，造成有些资源的数据抓取不全。&lt;/p&gt;
&lt;p&gt;经过压测查看
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>7.22~7.23双休工作总结</title>
    <link href="http://dingran.tk/2017/07/23/7-22-7-23%E5%8F%8C%E4%BC%91%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/07/23/7-22-7-23双休工作总结/</id>
    <published>2017-07-23T07:37:35.000Z</published>
    <updated>2017-07-23T08:11:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一阵主要的工作重点是忙在DTC的系统改造，上周主要是在DTC的余位查询抓取12306结果，分析构造结果、merge价格数据等单独重写了几个类。原来的人写的代码实在是不能进行扩展，我知道这不符合开闭原则，但是现在系统问题太多，不改实在不行了。</p>
<p>我将余位查询改为自己封装的httpUtil，这个类很简单，之前搞了很多回调方法，再添加动态USER-AGENT的时候就特别麻烦。自己写了一个，其实网上有很多例子，拿下来修改修改，就可以为自己所用了。然后是12306余位分析，这个之前改完了，后面有个价格merge的过程，这个我改为生产者消费者模式，因为抓取价格和经停站全部用免费代理ip去抓，速度上很慢，所以我创建blockingqueue，不停往里面放数据，后面有两个消费者去消费，如果放入的数据超过queue的最大值（有界限），停止放入数据，这样可以保护系统不内存溢出。</p>
<p>上面的都是我抽出类，在diamond的动态配置里面可以随便切过来切过去。上周一，我上线了一般，切到新逻辑，表现还不错，周三我改了一版，再次上线，这次就有问题了，每次都是这样上线一段时间后，系统的数据就不再更新了。我知道是哪个地方又出现了瓶颈了，及时让性能小组去压测，也压不出来问题到底在哪，我大概分析了一下应该是哪个线程池发生了堆积，造成请求堆积进而不发生数据更新。</p>
<p>于是我写了个线下接口，将所有线程池的数据全部打印出来，这个及时是用jvisualvm也是看不出来的，我发布到测试环境，写了个小程序用10个线程并发去压测，果然，过了一段时间，请求数据不再更新。我调用线程池接口发现在开始出发抓取12306的线程池的queue里面已经堆积了上百的数据，也就是说，新过来的请求已经不能够及时出发抓取，这就尴尬了，排查一遍代码，修改了一下，再次发布，这个瓶颈已经解决了，按照去年的一天3000W访问量，我将今年的单日最大设置为6000W的访问，平均到每秒大概为27个请求左右，也就是说一台实例每秒接收27个左右的请求，那我就拿这个频率去压测系统，没过多久，分析12306数据和merge数据的线程池也到达瓶颈，采用责任链模式，做完一道工序交给下个工序这样去处理，平滑度过这个高峰期，防止在一个节点上发生堆积，然后再次发布测试，在进行压测，过了20分钟再次查看线程池状况，一切都在coresize的范围内运行，很顺畅，但是最后merge缓存和发送mq的时候发生堆积了，还是如上，我将两个分开，由于这两步操作数据量非常大，还是采用生产者消费者模式进行写缓存和发送mq，这期间我发现发送mq比写缓存的速度还要慢很多，我将发送ma单独创建线程池去操作，这样用了7.22~23号两天，我将系统做了不小的改动，23号我主要进行的是系统的压测。以25个每秒左右的访问量进行压测，系统表现的很稳定，但是价格的问题还是卡了很多，还有发送的mq卡的问题其他的线程池表现的正常。价格问题后面我准备用分布式+MQ去处理，因为一个实例处理起来实在是太慢了，将线上所有的服务器全部用起来提升抓取效率，而不是让一台累死，其他的都闲着蛋疼。</p>
<p>本次改造还有就是对抢票接口和余位接口的缓存进行相互更新。抢票接口就是没有价格的接口，余位是包含价格的，但是抢票接口的刷取频繁度是要高于余位接口的，这两个接口的缓存不是同一套，但是现实余位的数据却是一样的，这里面有我的问题，当初是自己没有将这两个接口搞清楚，其实完全可以用一个接口就搞定了，搞出两个其实也并不是没什么用，也算是自己搞了一套自己的代码出来，但是爬取效率还是很高的。这样两个接口相互更新缓存就可以节省一批代理ip消耗，留给有需要的站站对使用。</p>
<p>问题还在，坑还很多，还有更多的路要走。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一阵主要的工作重点是忙在DTC的系统改造，上周主要是在DTC的余位查询抓取12306结果，分析构造结果、merge价格数据等单独重写了几个类。原来的人写的代码实在是不能进行扩展，我知道这不符合开闭原则，但是现在系统问题太多，不改实在不行了。&lt;/p&gt;
&lt;p&gt;我将余位查询改为
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>总结最近一段时间工作</title>
    <link href="http://dingran.tk/2017/07/19/%E6%80%BB%E7%BB%93%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%B7%A5%E4%BD%9C/"/>
    <id>http://dingran.tk/2017/07/19/总结最近一段时间工作/</id>
    <published>2017-07-19T08:17:42.000Z</published>
    <updated>2017-07-19T08:32:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>好几天没有写点东西了，是这一段时间忙的太累了。</p>
<p>前一段时间连续上了4次线都失败了，结果发现是在一个if后面没有做有效的判断造成死循环了，影响请求的返回，犯了这么低级的错误，也确实难以饶恕，以后编写代码一定要仔细认真确认。</p>
<p>妈妈来了三周，这周1回去了，心里面有点不舒服，没办法。</p>
<p>工作上自从京东接入途牛火车票查询以来，事情一天比一天多，而且没事就抄送CEO,COO，这让我有点难以理解，如果你们有事我们也抄送刘强东，是不是也让你菊花一紧。</p>
<p>有事说事，没事总往上捅是干嘛呢？最近DTC系统整改很大，我把余位接口和价格接口都重新开辟了新的接口，新的类，现在在线上跑没有什么问题，至于改的原因是原来的代码真的是不改不行了，按照软件的开闭原则，这确实是不是好的主意，但是如果维护成本太大，不改简直是浪费脑细胞。还差经停站，经停站我得重新设计一下。</p>
<p>最近加了几天班，都是集中搞一些数据，之前显示数据刷新中，现在使用线上代理ip+免费代理ip+app反刷集中获取余位，现在效果好了很多了</p>
<p>后面事情还有很多，比如分布式处理价格、经停站等</p>
<p>再接再厉！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好几天没有写点东西了，是这一段时间忙的太累了。&lt;/p&gt;
&lt;p&gt;前一段时间连续上了4次线都失败了，结果发现是在一个if后面没有做有效的判断造成死循环了，影响请求的返回，犯了这么低级的错误，也确实难以饶恕，以后编写代码一定要仔细认真确认。&lt;/p&gt;
&lt;p&gt;妈妈来了三周，这周1回去
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>防刷限制ip设计</title>
    <link href="http://dingran.tk/2017/07/05/%E9%98%B2%E5%88%B7%E9%99%90%E5%88%B6ip%E8%AE%BE%E8%AE%A1/"/>
    <id>http://dingran.tk/2017/07/05/防刷限制ip设计/</id>
    <published>2017-07-05T07:24:02.000Z</published>
    <updated>2017-07-05T07:28:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，发现DTC的余位查询接口在每天的12~13点左右，流量飙升3倍左右，然后又回落，如果经过系统关键字查询发现查询是来自APP端的访问，那么这就有可能是我们的接口被人家给刷了，作为底层系统，我需要保证接口的高效性，如果接口被人刷了就会导致真正需要接口数据的准确性。</p>
<p>由于是底层系统，所以我没有办法获得客户端的ip，于是先让PHP把客户端ip透传过来，我对ip的查询速度进行限制。网上这种限制的资料太多了，等我设计好了再补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间，发现DTC的余位查询接口在每天的12~13点左右，流量飙升3倍左右，然后又回落，如果经过系统关键字查询发现查询是来自APP端的访问，那么这就有可能是我们的接口被人家给刷了，作为底层系统，我需要保证接口的高效性，如果接口被人刷了就会导致真正需要接口数据的准确性。
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>Linux下配置squid+账号密码认证+高匿</title>
    <link href="http://dingran.tk/2017/06/30/Linux%E4%B8%8B%E9%85%8D%E7%BD%AEsquid-%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81-%E9%AB%98%E5%8C%BF/"/>
    <id>http://dingran.tk/2017/06/30/Linux下配置squid-账号密码认证-高匿/</id>
    <published>2017-06-30T06:22:56.000Z</published>
    <updated>2017-06-30T06:54:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="squid-搭建过程"><a href="#squid-搭建过程" class="headerlink" title="squid 搭建过程"></a>squid 搭建过程</h1><p>由于我们之前使用的阿里云的代理ip配置的代理服务器，由于领导要我们使用亚马逊云配置代理服务器，所以交给我任务去配置代理服务器，还得兼容以前的形式，也就说账号+密码的形式登录代理，访问网站。</p>
<p>我觉得很简单，网上有很多配置的信息，结果搜下来有很多都是大家相互复制的垃圾文章，要不就是虎头蛇尾，要不就是没头没尾，弄得我脑袋都大了，经过昨天晚上的资料筛选，今天我开启了AWS的配置，创建了个实例就不说了直接跳入配置过程：</p>
<h2 id="首先先判断是否安装squid："><a href="#首先先判断是否安装squid：" class="headerlink" title="首先先判断是否安装squid："></a>首先先判断是否安装squid：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpm -q squid</div></pre></td></tr></table></figure>
<h2 id="如果安装了不行就卸载了吧"><a href="#如果安装了不行就卸载了吧" class="headerlink" title="如果安装了不行就卸载了吧"></a>如果安装了不行就卸载了吧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">rpm -e squid</div></pre></td></tr></table></figure>
<h2 id="再进行下载squid"><a href="#再进行下载squid" class="headerlink" title="再进行下载squid"></a>再进行下载squid</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">yum install squid</div></pre></td></tr></table></figure>
<h2 id="下载httpd-为后面进行认证做准备"><a href="#下载httpd-为后面进行认证做准备" class="headerlink" title="下载httpd 为后面进行认证做准备"></a>下载httpd 为后面进行认证做准备</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install httpd</div></pre></td></tr></table></figure>
<h2 id="下载好了后，配置-etc-squid-squid-conf-这个比较重要"><a href="#下载好了后，配置-etc-squid-squid-conf-这个比较重要" class="headerlink" title="下载好了后，配置/etc/squid/squid.conf 这个比较重要"></a>下载好了后，配置/etc/squid/squid.conf 这个比较重要</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#</div><div class="line"># INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS</div><div class="line"># =======================</div><div class="line"></div><div class="line"># 禁止缓存任何内容，纯代理</div><div class="line">cache deny all</div><div class="line"></div><div class="line"># 禁用access_log</div><div class="line">access_log none</div><div class="line"></div><div class="line"># 禁用cache_store log</div><div class="line">cache_store_log none</div><div class="line"></div><div class="line"># 禁用cache log</div><div class="line">cache_log /dev/null </div><div class="line"></div><div class="line"># 使用basic_nsca_auth认证</div><div class="line">auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd</div><div class="line">auth_param basic children 5</div><div class="line">auth_param basic credentialsttl 2 hours</div><div class="line">auth_param basic realm Do you have rights to access?</div><div class="line">auth_param basic casesensitive off</div><div class="line">acl ncsa_users proxy_auth REQUIRED</div><div class="line">http_access allow localnet</div><div class="line">http_access allow localhost</div><div class="line">http_access allow ncsa_users</div><div class="line">http_port 8888</div><div class="line"></div><div class="line">#以上配置部分要在http_access deny all语句之前。</div><div class="line"></div><div class="line"># 这部分可以放在配置文件末尾，避免被网站检测到你在使用proxy</div><div class="line"># =======================</div><div class="line">via off</div><div class="line">forwarded_for off</div><div class="line">request_header_access Allow allow all </div><div class="line">request_header_access Authorization allow all </div><div class="line">request_header_access WWW-Authenticate allow all </div><div class="line">request_header_access Proxy-Authorization allow all </div><div class="line">request_header_access Proxy-Authenticate allow all </div><div class="line">request_header_access Cache-Control allow all </div><div class="line">request_header_access Content-Encoding allow all </div><div class="line">request_header_access Content-Length allow all </div><div class="line">request_header_access Content-Type allow all </div><div class="line">request_header_access Date allow all </div><div class="line">request_header_access Expires allow all </div><div class="line">request_header_access Host allow all </div><div class="line">request_header_access If-Modified-Since allow all </div><div class="line">request_header_access Last-Modified allow all </div><div class="line">request_header_access Location allow all </div><div class="line">request_header_access Pragma allow all </div><div class="line">request_header_access Accept allow all </div><div class="line">request_header_access Accept-Charset allow all </div><div class="line">request_header_access Accept-Encoding allow all </div><div class="line">request_header_access Accept-Language allow all </div><div class="line">request_header_access Content-Language allow all </div><div class="line">request_header_access Mime-Version allow all </div><div class="line">request_header_access Retry-After allow all </div><div class="line">request_header_access Title allow all </div><div class="line">request_header_access Connection allow all </div><div class="line">request_header_access Proxy-Connection allow all </div><div class="line">request_header_access User-Agent allow all </div><div class="line">request_header_access Cookie allow all </div><div class="line">request_header_access All deny all</div><div class="line"># =======================</div></pre></td></tr></table></figure>
<p>squid.conf配置里面还有很多其他的配置，网上有很多详细的配置说明，这里不多介绍。在squid.conf开头我配置auth进行账号密码认证后才能访问。</p>
<h2 id="账号密码配置过程"><a href="#账号密码配置过程" class="headerlink" title="账号密码配置过程"></a>账号密码配置过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">htpasswd -c /etc/squid/passwd gavin</div><div class="line">#这里会让你设置密码</div><div class="line">##在确认一下密码</div><div class="line">###设置完成</div></pre></td></tr></table></figure>
<h2 id="校验配置文件配置"><a href="#校验配置文件配置" class="headerlink" title="校验配置文件配置"></a>校验配置文件配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">squid -z</div><div class="line">#如果squid 没有配置环境变量，到/usr/sbin下面执行squid</div></pre></td></tr></table></figure>
<p>执行完后会有一些信息，如果配置文件信息错误会有相关提示，更改就好</p>
<h2 id="最后启动squid"><a href="#最后启动squid" class="headerlink" title="最后启动squid"></a>最后启动squid</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">squid start</div></pre></td></tr></table></figure>
<h2 id="查看端口状况"><a href="#查看端口状况" class="headerlink" title="查看端口状况"></a>查看端口状况</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">netstat -anp|grep 8888</div></pre></td></tr></table></figure>
<p>最后退出云服务器，在本地浏览器配置代理使用服务器公网ip+端口号，打开百度后会有显示让你输入账号密码就成功了，输入账号密码就可以登录浏览网页了</p>
<p>完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;squid-搭建过程&quot;&gt;&lt;a href=&quot;#squid-搭建过程&quot; class=&quot;headerlink&quot; title=&quot;squid 搭建过程&quot;&gt;&lt;/a&gt;squid 搭建过程&lt;/h1&gt;&lt;p&gt;由于我们之前使用的阿里云的代理ip配置的代理服务器，由于领导要我们使用亚马逊
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>免费代理集成dtc使用明细</title>
    <link href="http://dingran.tk/2017/06/28/%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E9%9B%86%E6%88%90dtc%E4%BD%BF%E7%94%A8%E6%98%8E%E7%BB%86/"/>
    <id>http://dingran.tk/2017/06/28/免费代理集成dtc使用明细/</id>
    <published>2017-06-28T03:14:06.000Z</published>
    <updated>2017-06-28T10:10:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>经历种种问题，终于将免费代理ip集成到DTC系统当中，之前由于各种问题，被我暂停，6.26号上线后，正式被我打开，打开后，在6.27号跑了一天后，我可以统计代理ip和免费代理ip的使用信息，其中代理ip使用了近150W次，而成功爬取数据成功的只有一半，再看免费代理ip，代替花钱买的代理ip抓取数据并且成功的数量在130w左右，说明了什么？免费代理ip几乎帮助dtc系统顶了将近一半的查询12306的数据。</p>
<p>免费代理ip质量参差不齐，所以用它们去抓取价格、抓取经停站简直是绝配了，这两天我将代理ip和免费代理ip的使用明细全部统计出来，余位接口、抢票接口、价格接口、经停站接口等使用了多少，失败了多少，各个角度去统计ip使用率，为后面更好统计我们使用代理ip的数量提供了更好的数据支持（可恶的黄甲天天催）。</p>
<p>这是上线第一天的数据量，但是从我今天的统计来看，免费代理ip的有效率占ip使用总数比例几乎是1：1的，有所增加，这也是情理之中的，因为随着时间的增长，花钱买的代理ip的有效率肯定会下降的，但是免费代理ip就会有新鲜的ip加进来，维持高效爬取数据，所以最终我初步断定免费代理ip能够贡献的爬取树量占花钱买的代理ip的贡献量50%左右,这是一个挺不错的数字,但是今天我却发现免费代理ip使用数量和我们线上买的代理ip使用的总数量一致，但是但是但是说三遍，线上有47%的失败率。什么意思?就是说免费代理ip的贡献率是我们花钱买到的代理ip的三倍左右，如果我们之前使用1000个代理ip现在我们就可以少买666个代理ip，一个代理ip80块，就是5w+，也就说至少可以节省一半的ip的预算。</p>
<p>这个小爬虫是我自己的想法，当初不被任何人看好，现在却带来了巨大的红利，我会继续再接再厉，提高抓取爬虫的有效率，继续做点有意义的事情出来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经历种种问题，终于将免费代理ip集成到DTC系统当中，之前由于各种问题，被我暂停，6.26号上线后，正式被我打开，打开后，在6.27号跑了一天后，我可以统计代理ip和免费代理ip的使用信息，其中代理ip使用了近150W次，而成功爬取数据成功的只有一半，再看免费代理ip，代替
    
    </summary>
    
      <category term="日记月累" scheme="http://dingran.tk/categories/%E6%97%A5%E8%AE%B0%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>集成爬虫到DTC系统以及相关问题总结</title>
    <link href="http://dingran.tk/2017/06/23/%E9%9B%86%E6%88%90%E7%88%AC%E8%99%AB%E5%88%B0DTC%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://dingran.tk/2017/06/23/集成爬虫到DTC系统以及相关问题总结/</id>
    <published>2017-06-23T07:16:58.000Z</published>
    <updated>2017-06-23T07:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>6.21号，我把带有爬取免费代理ip的爬虫放到线上，结果部署完成后发现redis不停的报一个错–unexpected stream。上网搜了一下，大概都是缓存空间不够或者多个线程一起调用的问题，但是我觉得用起来根不是这些问题。在测试环境都没有发现这种问题。后来请教运维相关人员瞬间我知道自己出现的问题在哪了。</p>
<p>在代码里面，我使用brpop命令来进行监听某个redis队列是否有数据，类似java的blockingqueue，我之前满心欢喜，这个功能真的好用，但是到了线上就完犊子了，原因是我们线上的redis使用的twemproxy这个twitter的redis代理来进行redis的管理。这个twemproxy可以自动剔除坏掉的节点，比较好用，但是它也有它的缺点就是它不支持一些redis的命令，brpop是其中一个，还有订阅发布等都不支持。有点沮丧，没办法，只能自己去实现这功能了。</p>
<p>昨天6.22号又紧急上线了，我是搭车上线主要是修复一些小问题，顺便把redis这个brpop这个修改了。然后再次发布，到线上后一切正常，然后到了今天早上，我来的时候突然发现dtc系统不提供服务了，经过visualvm链接线上的jvm查看，看见线程活跃说已经达到2800+了，我知道是自己在代码里面创建了一个线程池频繁销毁启动造成的，还好自己做了开关，我将开关关闭，将每台服务器都启动了一遍，多有实例都可以提供服务，没有问题。再看代码再将销毁线程池的地方再次修改，等待下次上线日。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6.21号，我把带有爬取免费代理ip的爬虫放到线上，结果部署完成后发现redis不停的报一个错–unexpected stream。上网搜了一下，大概都是缓存空间不够或者多个线程一起调用的问题，但是我觉得用起来根不是这些问题。在测试环境都没有发现这种问题。后来请教运维相关人
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
  <entry>
    <title>DTC集成智能小爬虫抓取免费ip</title>
    <link href="http://dingran.tk/2017/06/18/DTC%E9%9B%86%E6%88%90%E6%99%BA%E8%83%BD%E5%B0%8F%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%E5%85%8D%E8%B4%B9ip/"/>
    <id>http://dingran.tk/2017/06/18/DTC集成智能小爬虫抓取免费ip/</id>
    <published>2017-06-17T16:40:05.000Z</published>
    <updated>2017-06-17T17:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>6.18，年中了，自己马上就要在途牛干了将近1年了，回头望来感慨万千。哎，华奥司机是不是走的有点早啊，再呆上3个月，可能比你之前呆的那一年经历的坑还多呢。</p>
<p>已经是深夜，今天还是父亲节，今天早上起来得给父亲打个电话，谁让我是个大孝子呢，哎没办法。没事写写博客回忆今天做的事情也是蛮快乐的事情呀。</p>
<p>这两天是京东618的日子，每个组都需要有个人值班，虽说我不是这个值班的人，但是我还是本着“工（赚）作（加）至（班）上（费）”的原则还是不请自来了，既然来了也要必须做点事情呀，谁让我的价值观这么高呢。扯远了开始正题：</p>
<p>我先在自己的机器上搭建了一个小java工程，这个工程主要是用来爬取网上的免费代理ip，这一段时间以来12306几乎把我们所有的代理ip全部封掉了，即使买一些新的上去，最多几分钟就挂了，所以我需要一些炮灰来帮我刷新一些数据。由于代理ip不够用了，幸亏之前上了APP反刷（不是火车票列表反刷），之前不看好的功能现在居然成了主力，如果这个功能不上的话，也许数据中心真就直接倒闭了。但是由于查询量太大，app反刷也有些扛不住了，不得已走缓存了，所以数据准确性还真的有待提升。但是这只是个临时的策略，代理ip还是必须得上，否则数据的准确度绝对达不到的。</p>
<p>我把代理的逻辑仔细排查了一下（都看了860遍了，谁写破B玩应），发现了代理ip耗时最多的地方就是价格抓取和经停站的抓取，一次简单的查询，到了后面异步抓取了N多数据，所以代理ip消耗很大，所以有了我之前写的小智能爬虫。</p>
<p>这个爬虫很简单，就是不停的分析页面，抓取有效的信息，不能抓取的过快，否则也有会被封的危险。我在本机上跑的时候很短时间轻松抓取3~5w的代理ip，量很大，但是都需要check，check是最费时的，这么多抓来的ip靠线程池check真是太慢了，我在本机上起了2000+线程直接报错不能在创建线程了，虽然check的慢，但是还是有很多可以用的，中午有一阵居然可以获取2000+的有效代理ip，平时的话也就500左右。</p>
<p>我当初想在本地跑程序，将check后的代理ip放给线上，后来发现本地check太慢，而且不够灵活，我需要随时能够抓取发往线上，线上消耗这个代理ip的速度太惊人了，几乎放上去瞬间就被用光了，所以我还是决定将这个spider集成到dtg里面，作为一个独立的模块，添加定时任务，跑的时候，将没有check的ip用redis队列push进去，由于线上有很多实例，所以我在每个实例上进行监听这个队列，有数据在pop出来，pop500到本地，然后不够500在pop，本地就check数据，这样通过集群的话，check代理ip效率会更高，否则抓取的这么多的代理ip check不完就浪费了。check的时候用线程池，这个都会想到，但是check这个代理ip可能会花费很长时间，什么意思呢？就是线程池会满，如果到了下次触发抓取的时候，继续check这么下去，线程池不崩溃才怪呢。所以我尝试了好多方法，终于找到了一种每次触发都重新创建线程池，之前没处理的线程池直接shutdown掉，给后来的让位置，加上使用单例模式跑起来几乎没有什么问题。我在本地测试，启动在190个线程左右，开始check的时候线程飙到400左右，shutdown后落回200左右，然后定时再触发，再次回到400，这样往复，没错虽然可能会消耗很多资源，但是总起评价来还是值得的。</p>
<p>今天算是把代理集成起来，争取下周上线，后面再把统计抓取免费代理ip数量，check后的数量，真正使用的数量每隔半个小时统计出来，发到我的邮箱。这样可以给黄甲看看当初他看不起的免费代理ip到底支起了多大的天空。</p>
<p>困了，不早了，就到这里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6.18，年中了，自己马上就要在途牛干了将近1年了，回头望来感慨万千。哎，华奥司机是不是走的有点早啊，再呆上3个月，可能比你之前呆的那一年经历的坑还多呢。&lt;/p&gt;
&lt;p&gt;已经是深夜，今天还是父亲节，今天早上起来得给父亲打个电话，谁让我是个大孝子呢，哎没办法。没事写写博客回忆
    
    </summary>
    
      <category term="日积月累" scheme="http://dingran.tk/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
    
      <category term="途牛" scheme="http://dingran.tk/tags/%E9%80%94%E7%89%9B/"/>
    
  </entry>
  
</feed>
